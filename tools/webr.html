<!--
The entire section is hidden by default (`display: none` on `webr-toggle`).
When the JS module loads (pkgdown site), the toggle is flipped and it shows the container.
On GitHub, the JS never runs, so nothing is displayed.
-->

<!--- CSS -->

<style>
/* WebR Editor Styles */
#webr-container {
  border: 1px solid #dee2e6;
  border-radius: 0.375rem;
  padding: 1rem;
  margin: 1rem 0;
  background-color: #f8f9fa;
}

.webr-status {
  margin-bottom: 0.75rem;
  padding: 0.5rem 0.75rem;
  background-color: #e7f1ff;
  border-radius: 0.25rem;
  font-size: 0.9rem;
  color: #0c5460;
}

.webr-editor {
  width: 100%;
  min-height: 100px;
  padding: 0.75rem;
  font-family: 'Source Code Pro', Consolas, 'Liberation Mono', Menlo, monospace;
  font-size: 0.875rem;
  background-color: #ffffff;
  border: 1px solid #ced4da;
  border-radius: 0.25rem;
  box-sizing: border-box;
  resize: vertical;
}

.webr-editor:focus {
  border-color: #86b7fe;
  outline: 0;
  box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
}

.webr-run-btn {
  margin-bottom: 0.75rem;
  padding: 0.5rem 1.5rem;
  font-size: 0.9rem;
  font-weight: 500;
  color: #fff;
  background-color: #447099;
  border: none;
  border-radius: 0.25rem;
  cursor: pointer;
  transition: background-color 0.15s ease-in-out;
}

.webr-run-btn:hover:not(:disabled) {
  background-color: #375a7a;
}

.webr-run-btn:disabled {
  opacity: 0.65;
  cursor: not-allowed;
}

.webr-output {
  width: 100%;
  margin: 0.75rem 0 0 0;
  padding: 0.75rem;
  font-family: 'Source Code Pro', Consolas, 'Liberation Mono', Menlo, monospace;
  font-size: 0.875rem;
  background-color: #ffffff;
  color: #212529;
  border: 1px solid #ced4da;
  border-radius: 0.25rem;
  box-sizing: border-box;
}

.webr-output-plot {
  max-width: 100%;
  margin: 0.75rem auto 0 auto;
  background-color: #ffffff;
  border: 1px solid #ced4da;
  border-radius: 0.25rem;
}

.webr-fallback {
  padding: 1rem;
  text-align: center;
  color: #6c757d;
}

.webr-fallback a {
  color: #0d6efd;
  text-decoration: none;
}

.webr-fallback a:hover {
  text-decoration: underline;
}
</style>

<!--- UI -->
<!--- Can't indent, otherwise it gets treated as markdown -->

<div id="webr-toggle" style="display: none;">
<h3>Try it</h3>
<div id="webr-container">

<div class="webr-status"></div>
<button class="webr-run-btn" disabled>Run Code</button>
<textarea class="webr-editor">starwars |>
  filter(species == "Human") |>
  select(name, homeworld) |>
  arrange(name)</textarea>
<pre class="webr-output" style="display: none;"></pre>
<canvas class="webr-output-plot" style="display: none;"></canvas>

</div>
</div>

<!--- JavaScript -->

<script type="module">
  // This module only runs on the pkgdown site (not GitHub) because GitHub
  // doesn't execute JS. The container is hidden by default, so on GitHub
  // nothing is displayed. This script shows the container on pkgdown.
  import { WebR } from 'https://webr.r-wasm.org/latest/webr.mjs';

  document.addEventListener('DOMContentLoaded', async () => {
    // Toggle the container on (hidden by default for GitHub)
    const toggle = document.getElementById('webr-toggle');
    if (!toggle) {
      return;
    }
    toggle.style.display = 'block';

    const container = document.getElementById('webr-container');
    if (!container) {
      return;
    }

    const statusEl = container.querySelector('.webr-status');
    const editorEl = container.querySelector('.webr-editor');
    const outputEl = container.querySelector('.webr-output');
    const outputPlotEl = container.querySelector('.webr-output-plot');
    const runBtn = container.querySelector('.webr-run-btn');

    const updateStatus = (msg, loading = true) => {
      if (statusEl) {
        statusEl.innerHTML = loading
        ? '<span class="spinner-border spinner-border-sm me-2"></span>' + msg
        : msg;
      }
    };

    updateStatus('Initializing WebR...');

    try {
      const webR = new WebR();
      await webR.init();

      updateStatus('Installing dplyr (this may take a moment)...');
      await webR.installPackages(['dplyr'], { quiet: true });

      updateStatus('Loading dplyr...');
      await webR.evalRVoid('library(dplyr)');

      if (statusEl) {
        // Finished with status updates
        statusEl.style.display = 'none';
      }

      runBtn.disabled = false;
      runBtn.addEventListener('click', async () => {
        runBtn.disabled = true;

        // About to run code, show `Running...` to the user
        outputEl.style.display = 'block';
        outputEl.textContent = 'Running...';

        // Clear previous plots and hide the plot canvas
        outputPlotEl.style.display = 'none';
        outputPlotEl.textContent = null;

        const code = editorEl.value;
        let shelter = await new webR.Shelter();

        try {
          let capture = await shelter.captureR(
            code,
            {
              withAutoprint: true,
              // This gives us an R object in `val.data` when `val.type` is `"error"` or `"warning"`
              // so that we can recall `conditionMessage()`
              throwJsException: false
            }
          );

          // Extract output divs
          const elements = capture.output.map(async (val) => {
            // webr doesn't use `captureCondition()` correctly yet, so we manually
            // handle error and warning cases by calling `conditionMessage()` ourselves
            // https://github.com/r-wasm/webr/issues/281
            const element = document.createElement('div');

            if (val.type === 'stdout') {
              element.textContent = val.data;
            } else if (val.type === 'stderr') {
              element.style.color = 'red';
              element.textContent = val.data;
            } else if (val.type === 'error') {
              element.style.color = 'red';
              const message = await webR.evalRString(`conditionMessage(cnd)`, { env: { cnd: val.data }});
              element.textContent = message.includes("\n") ? `Error:\n${message}` : `Error: ${message}`;
            }else if (val.type === 'warning') {
              element.style.color = 'orange';
              const message = await webR.evalRString(`conditionMessage(cnd)`, { env: { cnd: val.data }});
              element.textContent = message.includes("\n") ? `Warning:\n${message}` : `Warning: ${message}`;
            }

            return element;
          });

          // Clear last output, or initial `Running...`
          outputEl.textContent = null;

          // Show output if we have any, or remove output div entirely if no output
          if (elements.length > 0) {
            const outputs = await Promise.all(elements);
            outputEl.append(...outputs);
          } else {
            outputEl.style.display = 'none';
          }

          // Show last image if we have any.
          // Doesn't make much sense to try and show multiple.
          if (capture.images.length > 0) {
            outputPlotEl.style.display = 'block';

            // Use the last image (most recent plot)
            const image = capture.images[capture.images.length - 1];

            // Set canvas dimensions to match the image
            outputPlotEl.width = image.width;
            outputPlotEl.height = image.height;

            outputPlotEl.getContext('2d').drawImage(image, 0, 0);
          }
        } finally {
          runBtn.disabled = false;
          shelter.purge();
        }
      });
    } catch (e) {
      updateStatus('Failed to initialize WebR: ' + e.message, false);
      console.error('WebR initialization failed:', e);
    }
  });
</script>
