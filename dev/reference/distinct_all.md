# Select distinct rows by a selection of variables

**\[superseded\]**

Scoped verbs (`_if`, `_at`, `_all`) have been superseded by the use of
[`pick()`](https://dplyr.tidyverse.org/dev/reference/pick.md) or
[`across()`](https://dplyr.tidyverse.org/dev/reference/across.md) in an
existing verb. See
[`vignette("colwise")`](https://dplyr.tidyverse.org/dev/articles/colwise.md)
for details.

These [scoped](https://dplyr.tidyverse.org/dev/reference/scoped.md)
variants of
[`distinct()`](https://dplyr.tidyverse.org/dev/reference/distinct.md)
extract distinct rows by a selection of variables. Like
[`distinct()`](https://dplyr.tidyverse.org/dev/reference/distinct.md),
you can modify the variables before ordering with the `.funs` argument.

## Usage

``` r
distinct_all(.tbl, .funs = list(), ..., .keep_all = FALSE)

distinct_at(.tbl, .vars, .funs = list(), ..., .keep_all = FALSE)

distinct_if(.tbl, .predicate, .funs = list(), ..., .keep_all = FALSE)
```

## Arguments

- .tbl:

  A `tbl` object.

- .funs:

  A function `fun`, a quosure style lambda `~ fun(.)` or a list of
  either form.

- ...:

  Additional arguments for the function calls in `.funs`. These are
  evaluated only once, with [tidy
  dots](https://rlang.r-lib.org/reference/dyn-dots.html) support.

- .keep_all:

  If `TRUE`, keep all variables in `.data`. If a combination of `...` is
  not distinct, this keeps the first row of values.

- .vars:

  A list of columns generated by
  [`vars()`](https://dplyr.tidyverse.org/dev/reference/vars.md), a
  character vector of column names, a numeric vector of column
  positions, or `NULL`.

- .predicate:

  A predicate function to be applied to the columns or a logical vector.
  The variables for which `.predicate` is or returns `TRUE` are
  selected. This argument is passed to
  [`rlang::as_function()`](https://rlang.r-lib.org/reference/as_function.html)
  and thus supports quosure-style lambda functions and strings
  representing function names.

## Grouping variables

The grouping variables that are part of the selection are taken into
account to determine distinct rows.

## Examples

``` r
df <- tibble(x = rep(2:5, each = 2) / 2, y = rep(2:3, each = 4) / 2)

distinct_all(df)
#> # A tibble: 4 × 2
#>       x     y
#>   <dbl> <dbl>
#> 1   1     1  
#> 2   1.5   1  
#> 3   2     1.5
#> 4   2.5   1.5
# ->
distinct(df, pick(everything()))
#> # A tibble: 4 × 2
#>       x     y
#>   <dbl> <dbl>
#> 1   1     1  
#> 2   1.5   1  
#> 3   2     1.5
#> 4   2.5   1.5

distinct_at(df, vars(x,y))
#> # A tibble: 4 × 2
#>       x     y
#>   <dbl> <dbl>
#> 1   1     1  
#> 2   1.5   1  
#> 3   2     1.5
#> 4   2.5   1.5
# ->
distinct(df, pick(x, y))
#> # A tibble: 4 × 2
#>       x     y
#>   <dbl> <dbl>
#> 1   1     1  
#> 2   1.5   1  
#> 3   2     1.5
#> 4   2.5   1.5

distinct_if(df, is.numeric)
#> # A tibble: 4 × 2
#>       x     y
#>   <dbl> <dbl>
#> 1   1     1  
#> 2   1.5   1  
#> 3   2     1.5
#> 4   2.5   1.5
# ->
distinct(df, pick(where(is.numeric)))
#> # A tibble: 4 × 2
#>       x     y
#>   <dbl> <dbl>
#> 1   1     1  
#> 2   1.5   1  
#> 3   2     1.5
#> 4   2.5   1.5

# You can supply a function that will be applied before extracting the distinct values
# The variables of the sorted tibble keep their original values.
distinct_all(df, round)
#> # A tibble: 3 × 2
#>       x     y
#>   <dbl> <dbl>
#> 1     1     1
#> 2     2     1
#> 3     2     2
# ->
distinct(df, across(everything(), round))
#> # A tibble: 3 × 2
#>       x     y
#>   <dbl> <dbl>
#> 1     1     1
#> 2     2     1
#> 3     2     2
```
