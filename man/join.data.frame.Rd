% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/join.r
\name{join.data.frame}
\alias{join.data.frame}
\alias{inner_join.data.frame}
\alias{left_join.data.frame}
\alias{right_join.data.frame}
\alias{full_join.data.frame}
\alias{semi_join.data.frame}
\alias{anti_join.data.frame}
\alias{nest_join.data.frame}
\title{Join methods for data frames}
\usage{
\method{inner_join}{data.frame}(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  na_matches = pkgconfig::get_config("dplyr::na_matches")
)

\method{left_join}{data.frame}(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  na_matches = pkgconfig::get_config("dplyr::na_matches")
)

\method{right_join}{data.frame}(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  na_matches = pkgconfig::get_config("dplyr::na_matches")
)

\method{full_join}{data.frame}(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = pkgconfig::get_config("dplyr::na_matches")
)

\method{semi_join}{data.frame}(
  x,
  y,
  by = NULL,
  copy = FALSE,
  ...,
  na_matches = pkgconfig::get_config("dplyr::na_matches")
)

\method{anti_join}{data.frame}(
  x,
  y,
  by = NULL,
  copy = FALSE,
  ...,
  na_matches = pkgconfig::get_config("dplyr::na_matches")
)

\method{nest_join}{data.frame}(x, y, by = NULL, copy = FALSE, keep = FALSE, name = NULL, ...)
}
\arguments{
\item{x, y}{Data frames}

\item{by}{A character vector of variables to join by.  If \code{NULL}, the
default, \verb{*_join()} will do a natural join, using all variables with
common names across the two tables. A message lists the variables so
that you can check they're right (to suppress the message, simply
explicitly list the variables that you want to join).

To join by different variables on x and y use a named vector.
For example, \code{by = c("a" = "b")} will match \code{x.a} to
\code{y.b}.}

\item{copy}{If \code{x} and \code{y} are not from the same data source,
and \code{copy} is \code{TRUE}, then \code{y} will be copied into the
same src as \code{x}.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.}

\item{suffix}{If there are non-joined duplicate variables in \code{x} and
\code{y}, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.}

\item{...}{Included for compatibility with the generic; otherwise ignored.}

\item{na_matches}{Should \code{NA} and \code{NaN} values match one another?

Use \code{"never"} to always treat two \code{NA} or \code{NaN} values as different, like
joins for database sources, similarly to \code{merge(incomparables = FALSE)}.
The default, \code{"na"}, always treats two \code{NA} or \code{NaN} values as equal,
like \code{\%in\%}, \code{\link[=match]{match()}}, \code{\link[=merge]{merge()}}.

Users and package authors can change the default behavior by calling
\code{pkgconfig::set_config("dplyr::na_matches" = "never")}.}

\item{keep}{If \code{TRUE} the by columns are kept in the nesting joins.}

\item{name}{The name of the list column nesting joins create.
If \code{NULL} the name of \code{y} is used.}
}
\description{
This page describes the details of the \link{join} generics when applied to
data frames and tibbles.

All methods treat the \code{x} input as primary: the return value will be the
same type as \code{x} and the rows will in be the same order (duplicated where
necessary, and where needed missing rows from \code{y} will be added to the end.)
}
\examples{
df1 <- data.frame(x = c(1, NA), y = 2)
df2 <- data.frame(x = c(1, NA), z = 3)

# By default, NAs match other NAs so that there are two
# rows in the output:
left_join(df1, df2)

# You can optionally request that NAs don't match, giving a
# a result that more closely resembles SQL joins
left_join(df1, df2, na_matches = "never")
}
