% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/join.r
\name{join}
\alias{join}
\alias{inner_join}
\alias{left_join}
\alias{right_join}
\alias{full_join}
\alias{semi_join}
\alias{anti_join}
\alias{nest_join}
\title{Join two tbls together}
\usage{
inner_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

left_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

right_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

full_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

semi_join(x, y, by = NULL, copy = FALSE, ...)

anti_join(x, y, by = NULL, copy = FALSE, ...)

nest_join(x, y, by = NULL, copy = FALSE, keep = FALSE, name = NULL, ...)
}
\arguments{
\item{x, y}{tbls to join}

\item{by}{a character vector of variables to join by.  If \code{NULL}, the
default, \verb{*_join()} will do a natural join, using all variables with
common names across the two tables. A message lists the variables so
that you can check they're right (to suppress the message, simply
explicitly list the variables that you want to join).

To join by different variables on x and y use a named vector.
For example, \code{by = c("a" = "b")} will match \code{x.a} to
\code{y.b}.}

\item{copy}{If \code{x} and \code{y} are not from the same data source,
and \code{copy} is \code{TRUE}, then \code{y} will be copied into the
same src as \code{x}.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.}

\item{suffix}{If there are non-joined duplicate variables in \code{x} and
\code{y}, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.}

\item{...}{other parameters passed onto methods, for instance, \code{na_matches}
to control how \code{NA} values are matched.  See \link{join.tbl_df} for more.}

\item{keep}{If \code{TRUE} the by columns are kept in the nesting joins.}

\item{name}{the name of the list column nesting joins create. If \code{NULL} the name of \code{y} is used.}
}
\description{
These are generic functions that dispatch to individual tbl methods - see the
method documentation for details of individual data sources. \code{x} and
\code{y} should usually be from the same data source, but if \code{copy} is
\code{TRUE}, \code{y} will automatically be copied to the same source as \code{x}.
}
\section{Join types}{


Currently dplyr supports four types of mutating joins, two types of filtering joins, and
a nesting join.

\strong{Mutating joins} combine variables from the two data.frames:

\describe{
\item{\code{inner_join()}}{return all rows from \code{x} where there are matching
values in \code{y}, and all columns from \code{x} and \code{y}. If there are multiple matches
between \code{x} and \code{y}, all combination of the matches are returned.}

\item{\code{left_join()}}{return all rows from \code{x}, and all columns from \code{x}
and \code{y}. Rows in \code{x} with no match in \code{y} will have \code{NA} values in the new
columns. If there are multiple matches between \code{x} and \code{y}, all combinations
of the matches are returned.}

\item{\code{right_join()}}{return all rows from \code{y}, and all columns from \code{x}
and y. Rows in \code{y} with no match in \code{x} will have \code{NA} values in the new
columns. If there are multiple matches between \code{x} and \code{y}, all combinations
of the matches are returned.}

\item{\code{full_join()}}{return all rows and all columns from both \code{x} and \code{y}.
Where there are not matching values, returns \code{NA} for the one missing.}
}

\strong{Filtering joins} keep cases from the left-hand data.frame:

\describe{
\item{\code{semi_join()}}{return all rows from \code{x} where there are matching
values in \code{y}, keeping just columns from \code{x}.

A semi join differs from an inner join because an inner join will return
one row of \code{x} for each matching row  of \code{y}, where a semi
join will never duplicate rows of \code{x}.}

\item{\code{anti_join()}}{return all rows from \code{x} where there are not
matching values in \code{y}, keeping just columns from \code{x}.}
}

\strong{Nesting joins} create a list column of data.frames:

\describe{
\item{\code{nest_join()}}{return all rows and all columns from \code{x}. Adds a
list column of tibbles. Each tibble contains all the rows from \code{y}
that match that row of \code{x}. When there is no match, the list column is
a 0-row tibble with the same column names and types as \code{y}.

\code{nest_join()} is the most fundamental join since you can recreate the other joins from it.
An \code{inner_join()} is a \code{nest_join()} plus an \code{\link[tidyr:unnest]{tidyr::unnest()}}, and \code{left_join()} is a
\code{nest_join()} plus an \code{unnest(.drop = FALSE)}.
A \code{semi_join()} is a \code{nest_join()} plus a \code{filter()} where you check that every element of data has
at least one row, and an \code{anti_join()} is a \code{nest_join()} plus a \code{filter()} where you check every element has zero rows.
}
}
}

\section{Grouping}{


Groups are ignored for the purpose of joining, but the result preserves
the grouping of \code{x}.
}

\examples{
# "Mutating" joins combine variables from the LHS and RHS
band_members \%>\% inner_join(band_instruments)
band_members \%>\% left_join(band_instruments)
band_members \%>\% right_join(band_instruments)
band_members \%>\% full_join(band_instruments)

# "Filtering" joins keep cases from the LHS
band_members \%>\% semi_join(band_instruments)
band_members \%>\% anti_join(band_instruments)

# "Nesting" joins keep cases from the LHS and nests the RHS
band_members \%>\% nest_join(band_instruments)

# To suppress the message, supply by
band_members \%>\% inner_join(band_instruments, by = "name")
# This is good practice in production code

# Use a named `by` if the join variables have different names
band_members \%>\% full_join(band_instruments2, by = c("name" = "artist"))
# Note that only the key from the LHS is kept
}
