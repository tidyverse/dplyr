% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/case-when.R
\name{case-and-replace-when}
\alias{case-and-replace-when}
\alias{case_when}
\alias{replace_when}
\title{A general vectorised if-else}
\usage{
case_when(..., .default = NULL, .ptype = NULL, .size = NULL)

replace_when(x, ...)
}
\arguments{
\item{...}{<\code{\link[rlang:dyn-dots]{dynamic-dots}}> A sequence of two-sided
formulas. The left hand side (LHS) determines which values match this case.
The right hand side (RHS) provides the replacement value.

For \code{case_when()}:
\itemize{
\item The LHS inputs must be logical vectors.
\item The RHS inputs will be \link[vctrs:theory-faq-coercion]{cast} to their common
type, or to \code{.ptype} if provided.
\item The LHS inputs will be \link[vctrs:theory-faq-recycling]{recycled} to their
common size, for historical reasons. That said, we encourage all LHS
inputs to be the same size, which you can optionally enforce with
\code{.size}.
\item The RHS inputs will be \link[vctrs:theory-faq-recycling]{recycled} to the
common size of the LHS inputs.
}

For \code{replace_when()}:
\itemize{
\item The LHS inputs must be logical vectors.
\item The RHS inputs will be \link[vctrs:theory-faq-coercion]{cast} to the type of
\code{x}.
\item The LHS inputs must be the same size as \code{x}.
\item The RHS inputs will be \link[vctrs:theory-faq-recycling]{recycled} to the
same size as \code{x}.
}

\code{NULL} inputs are ignored.}

\item{.default}{The value used when all of the LHS inputs return either
\code{FALSE} or \code{NA}.

If provided, \code{.default}:
\itemize{
\item Will participate in the computation of the common type with the RHS
inputs, and will be \link[vctrs:theory-faq-coercion]{cast} to that common
type.
\item Will be \link[vctrs:theory-faq-recycling]{recycled} to the common size of the
LHS inputs.
}

If \code{NULL}, the default, a missing value will be used.

\code{NA} values in the LHS conditions are treated like \code{FALSE}, meaning that
the result at those locations will be assigned the \code{.default} value. To
handle missing values in the conditions differently, you must explicitly
catch them with another condition before they fall through to the
\code{.default}. This typically involves some variation of \code{is.na(x) ~ value}
tailored to your usage of \code{case_when()}.}

\item{.ptype}{An optional prototype declaring the desired output type. If
supplied, this overrides the common type of the RHS inputs.}

\item{.size}{An optional size declaring the desired output size. If supplied,
this overrides the common size computed from the LHS inputs.}

\item{x}{A vector.}
}
\value{
For \code{case_when()}, a new vector:
\itemize{
\item The size is the common size of the LHS inputs, or \code{.size}.
\item The type is the common type of the RHS inputs, or \code{.ptype}.
\item The names correspond to the names of the RHS input elements that are used
in the result.
}

For \code{replace_when()}, an updated version of \code{x}:
\itemize{
\item The size is the same size as \code{x}.
\item The type is the same type as \code{x}.
\item The names are the same names as \code{x}, regardless of any replacements,
consistent with \code{\link[base:replace]{base::replace()}} and \code{base::`[<-`}.
}
}
\description{
\code{case_when()} and \code{replace_when()} are two forms of vectorized \code{\link[=if_else]{if_else()}}.
They work by evaluating each case sequentially and using the first match for
each element to determine the corresponding value in the output vector.
\itemize{
\item Use \code{case_when()} when creating an entirely new vector.
\item Use \code{replace_when()} when updating an existing vector.
}

If no cases match, then for \code{case_when()} a \code{.default} is used as a final
"else" statement, and for \code{replace_when()} the original values from \code{x} are
retained.

\code{case_when()} is an R equivalent of the SQL "searched" \verb{CASE WHEN} statement.
}
\section{Connection between \code{case_when()} and \code{replace_when()}}{


The following two statements produce identical \code{result}s:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{result <- replace_when(x, lhs ~ rhs)

result <- case_when(lhs ~ rhs, .default = x, .ptype = x, .size = vec_size(x))
result <- vec_set_names(result, vec_names(x))
}\if{html}{\out{</div>}}

If you are replacing a few values within an existing vector, then
\code{replace_when()} is always a better choice because it is type stable and size
stable on \code{x}, pipes better, and better expresses intent.
}

\examples{
x <- 1:70
case_when(
  x \%\% 35 == 0 ~ "fizz buzz",
  x \%\% 5 == 0 ~ "fizz",
  x \%\% 7 == 0 ~ "buzz",
  .default = "unmatched"
)

# Like an if statement, the arguments are evaluated in order, so you must
# proceed from the most specific to the most general. This won't work:
case_when(
  x \%\% 5 == 0 ~ "fizz",
  x \%\% 7 == 0 ~ "buzz",
  x \%\% 35 == 0 ~ "fizz buzz",
  .default = "unmatched"
)

# If none of the cases match and no `.default` is supplied, NA is used:
case_when(
  x \%\% 35 == 0 ~ "fizz buzz",
  x \%\% 5 == 0 ~ "fizz",
  x \%\% 7 == 0 ~ "buzz"
)

# Note that `NA` values on the LHS are treated like `FALSE` and will be
# assigned the `.default` value. You must handle them explicitly if you
# want to use a different value. The exact way to handle missing values is
# dependent on the set of LHS conditions you use.
x[2:4] <- NA_real_
case_when(
  x \%\% 35 == 0 ~ "fizz buzz",
  x \%\% 5 == 0 ~ "fizz",
  x \%\% 7 == 0 ~ "buzz",
  is.na(x) ~ "nope",
  .default = "unmatched"
)

# `replace_when()` is useful when you're updating an existing vector,
# rather than creating an entirely new one. Note the so-far unused "puppy"
# factor level:
pets <- tibble(
  name = c("Max", "Bella", "Chuck", "Luna", "Cooper"),
  type = factor(
    c("dog", "dog", "cat", "dog", "cat"),
    levels = c("dog", "cat", "puppy")
  ),
  age = c(1, 3, 5, 2, 4)
)

# We can replace some values with `"puppy"` based on arbitrary conditions.
# Even though we are using a character `"puppy"` value, `replace_when()` will
# automatically cast it to the factor type of `type` for us.
pets |>
  mutate(
    type = type |> replace_when(type == "dog" & age <= 2 ~ "puppy")
  )

# Compare that with this `case_when()` call, which loses the factor class.
# It's always better to use `replace_when()` when updating a few values in
# an existing vector!
pets |>
  mutate(
    type = case_when(type == "dog" & age <= 2 ~ "puppy", .default = type)
  )

# `case_when()` and `replace_when()` evaluate all RHS expressions, and then
# construct their result by extracting the selected (via the LHS expressions)
# parts. For example, `NaN`s are produced here because `sqrt(y)` is evaluated
# on all of `y`, not just where `y >= 0`.
y <- seq(-2, 2, by = .5)
replace_when(y, y >= 0 ~ sqrt(y))

# These functions are particularly useful inside `mutate()` when you want to
# create a new variable that relies on a complex combination of existing
# variables
starwars |>
  select(name:mass, gender, species) |>
  mutate(
    type = case_when(
      height > 200 | mass > 200 ~ "large",
      species == "Droid" ~ "robot",
      .default = "other"
    )
  )

# `case_when()` is not a tidy eval function. If you'd like to reuse
# the same patterns, extract the `case_when()` call into a normal
# function:
case_character_type <- function(height, mass, species) {
  case_when(
    height > 200 | mass > 200 ~ "large",
    species == "Droid" ~ "robot",
    .default = "other"
  )
}

case_character_type(150, 250, "Droid")
case_character_type(150, 150, "Droid")

# Such functions can be used inside `mutate()` as well:
starwars |>
  mutate(type = case_character_type(height, mass, species)) |>
  pull(type)

# `case_when()` ignores `NULL` inputs. This is useful when you'd
# like to use a pattern only under certain conditions. Here we'll
# take advantage of the fact that `if` returns `NULL` when there is
# no `else` clause:
case_character_type <- function(height, mass, species, robots = TRUE) {
  case_when(
    height > 200 | mass > 200 ~ "large",
    if (robots) species == "Droid" ~ "robot",
    .default = "other"
  )
}

starwars |>
  mutate(type = case_character_type(height, mass, species, robots = FALSE)) |>
  pull(type)

# `replace_when()` can also be used in combination with `pick()` to
# conditionally mutate rows within multiple columns using a single condition.
# Here `replace_when()` returns a data frame with new `species` and `name`
# columns, which `mutate()` then automatically unpacks.
starwars |>
  select(homeworld, species, name) |>
  mutate(replace_when(
    pick(species, name),
    homeworld == "Tatooine" ~ tibble(
      species = "Tatooinese",
      name = paste(name, "(Tatooine)")
    )
  ))
}
