% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rows.R
\name{rows}
\alias{rows}
\alias{rows_insert}
\alias{rows_update}
\alias{rows_patch}
\alias{rows_upsert}
\alias{rows_delete}
\alias{rows_truncate}
\title{Manipulate individual rows}
\usage{
rows_insert(x, y, by = NULL, ..., copy = FALSE, inplace = NULL)

rows_update(x, y, by = NULL, ..., copy = FALSE, inplace = NULL)

rows_patch(x, y, by = NULL, ..., copy = FALSE, inplace = NULL)

rows_upsert(x, y, by = NULL, ..., copy = FALSE, inplace = NULL)

rows_delete(x, y, by = NULL, ..., copy = FALSE, inplace = NULL)

rows_truncate(x, ..., copy = FALSE, inplace = NULL)
}
\arguments{
\item{x}{Target table object.}

\item{y}{Source table object. All columns in \code{y} must exist in \code{x}.}

\item{by}{Key columns as unnamed character vector.
All columns in \code{by} must exist in \code{y} (and, by extension, in \code{x}).
The default is the first column of \code{y}.}

\item{...}{Other parameters passed onto methods.}

\item{copy}{If \code{x} and \code{y} are not from the same data source,
and \code{copy} is \code{TRUE}, then \code{y} will be copied into the
same src as \code{x}.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.}

\item{inplace}{This argument is only relevant for mutable backends,
e.g. databases or \pkg{dtplyr}.
For data frames, these operations always return a modified copy
of the data.
An informative message is given if set to \code{TRUE}.

For mutable backends, set to \code{FALSE} for running the operation
without updating the data in place.
In this mode, a modified version of \code{x} is returned, as for data frames.
This allows verifying the results of an operation before actually
applying it.
Set to \code{TRUE} to perform the update on the remote table.
The default is \code{FALSE} with an informative message.}
}
\value{
A tbl object of the same structure as \code{x}.
On mutable backends, same as \code{x} if \code{inplace = TRUE}.
}
\description{
\lifecycle{experimental}

These methods provide a framework for manipulating individual rows
in existing tables, modeled after the SQL operations
\code{INSERT}, \code{UPDATE} and \code{DELETE}.
All operations expect existing and new data to be compatible.

\code{rows_insert()} adds new rows.
This operation corresponds to \code{INSERT} in SQL.
If \code{by} is non-empty, no two rows with the same values in the key columns
are permitted.

\code{rows_update()} updates existing rows.
This operation corresponds to \code{UPDATE} in SQL.
\code{by} is mandatory and defaults to the first column in \code{y}.
No two rows with the same values may exist in the new data.
Each row in the new data must have exactly one corresponding row
in the existing data.

\code{rows_patch()} replaces missing values in existing rows.
This operation corresponds to \code{UPDATE} using \code{COALESCE} expressions in SQL.
It is similar to \code{rows_update()}, leaves non-missing values untouched.
\code{by} is mandatory and defaults to the first column in \code{y}.
No two rows with the same values may exist in the new data.
Each row in the new data must have exactly one corresponding row
in the existing data.

\code{rows_upsert()} updates matching rows and adds new rows for mismatches.
This operation corresponds to \verb{INSERT ON DUPLICATE KEY UPDATE} or
\verb{INSERT ON CONFLICT} in some SQL variants.
\code{by} is mandatory and defaults to the first column in \code{y}.
No two rows with the same values may exist in the new data.
Each row in the new data must have exactly one corresponding row
in the existing data.

\code{rows_delete()} deletes existing rows.
This operation corresponds to \code{DELETE} in SQL.
\code{by} is mandatory and defaults to the first column in \code{y}.

\code{rows_truncate()} removes all rows.
This operation corresponds to \code{TRUNCATE} in SQL.
\code{...} is ignored.
}
\examples{
data <- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2)
data

# Insert
rows_insert(data, tibble(a = 4, b = "z"))
try(rows_insert(data, tibble(a = 3, b = "z")))

# Update
rows_update(data, tibble(a = 2:3, b = "z"))
rows_update(data, tibble(b = "z", a = 2:3), by = "a")

# Variants: patch and upsert
rows_patch(data, tibble(a = 2:3, b = "z"))
rows_upsert(data, tibble(a = 2:4, b = "z"))

# Delete and truncate
rows_delete(data, tibble(a = 2:4))
rows_delete(data, tibble(a = 2:4, b = "b"))
rows_delete(data, tibble(a = 2:4, b = "b"), by = c("a", "b"))
rows_truncate(data)
}
