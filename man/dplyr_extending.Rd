% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R
\name{dplyr_extending}
\alias{dplyr_extending}
\alias{dplyr_row_slice}
\alias{dplyr_col_modify}
\alias{dplyr_df_restore}
\title{Extending dplyr}
\usage{
dplyr_row_slice(data, i, ...)

dplyr_col_modify(data, cols)

dplyr_df_restore(data, old)
}
\description{
\Sexpr[results=rd, stage=render]{lifecycle::badge("experimental")}

These three functions, along with \verb{names<-} and 1d \code{[}, provide a minimal
interface for extending dplyr to work with a new subclass of data frame. They
are experimental, and a stop-gap measure until more general tools become
available in vctrs, but may still be useful in the short-term if you have a
data frame class that you want to work with dplyr.
\itemize{
\item \code{arrange()}, \code{filter()}, \code{slice()}, \code{semi_join()}, and \code{anti_join()}
work by generating a vector of column indices, and then subsetting
with \code{dplyr_row_slice()}.
\item \code{mutate()} generates a list of new column value (using \code{NULL} to indicate
when columns should be deleted), then passes that to \code{dplyr_col_modify()}.
\code{transmute()} does the same then uses 1d \code{[} to select the columns.
\item \code{summarise()} works similarly to \code{mutate()} but the data modified by
\code{dplyr_col_modify()} comes from \code{group_data()}.
\item \code{select()} uses 1d \code{[} to select columns, then \verb{names<-} to rename them.
\code{rename()} just uses \verb{names<-}.
\item \code{inner_join()}, \code{left_join()}, \code{right_join()}, and \code{full_join()}
coerces \code{x} to a tibble, modify the rows, then use \code{dplyr_df_restore()}
to convert back to the same type as \code{x}.
\item \code{distinct()} does a \code{mutate()} if any expressions are present, then
uses 1d \code{[} to select variables to keep, then \code{dplyr_row_slice()} to
select distinct rows.
}

Note that \code{group_by()} and \code{ungroup()} don't use any of these tools and
you'll need to provide methods directly.
}
