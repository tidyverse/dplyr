% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select.R
\name{select}
\alias{select}
\title{Subset columns using their names and types}
\usage{
select(.data, ...)
}
\arguments{
\item{.data}{A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See \emph{Methods}, below, for
more details.}

\item{...}{<\code{\link[=dplyr_tidy_select]{tidy-select}}> One or more unquoted
expressions separated by commas. You can treat variable names like they
are positions, so you can use expressions like \code{x:y} to select ranges of
variables.}
}
\value{
An object of the same type as \code{.data}.
\itemize{
\item Rows are not affected.
\item Output columns are a subset of input columns, potentially with a different
order. Columns will be renamed if \code{new_name = old_name} form is used.
\item Data frame attributes are preserved.
\item Groups are maintained; you can not select off grouping variables.
}
}
\description{
Select (and optionally rename) variables in a data frame, using a concise
mini-language that makes it easy to refer to variables based on their name
(e.g. \code{a:f} selects all columns between \code{a} on the left to \code{f} on the
right). You can also use predicate functions like \link{is.numeric} to select
variables based on their properties.
}
\section{Useful functions}{

As well as using existing functions like \code{:} and \code{c()}, there are
a number of special functions that only work inside \code{select()}:
\itemize{
\item \code{\link[=any_of]{any_of()}}, \code{\link[=all_of]{all_of()}}.
\item \code{\link[=starts_with]{starts_with()}}, \code{\link[=ends_with]{ends_with()}}, \code{\link[=contains]{contains()}}, \code{\link[=matches]{matches()}}.
\item \code{\link[=num_range]{num_range()}}.
\item \code{\link[=group_cols]{group_cols()}}, \code{\link[=last_col]{last_col()}}.
\item \code{\link[=everything]{everything()}}.
}

You can also use predicate functions (functions that return a single \code{TRUE}
or \code{FALSE}) like \code{is.numeric}, \code{is.character}, and \code{is.factor}
to select variables with specific types.

Selections can be combined using Boolean algebra like:
\itemize{
\item \code{starts_with("a") & ends_with("x")}: start with "a" and end with "x"
\item \code{starts_with("a") | starts_with("b")}: start with "a" or "b"
\item \code{!starts_with("a")}: doesn't start with "a"
}

To remove variables from a selection, use \code{-}:
\itemize{
\item \code{starts_with("a") - ends_width("x")}: start with "a" and doesn't end with "x"
\item \code{is.numeric - c(a, b, c)}: numeric variables except for \code{a}, \code{b}, \code{c}.
}

See \link[tidyselect:select_helpers]{select helpers} for more details and
examples.

Note that except for \code{:}, \code{-} and \code{c()}, all complex expressions
are evaluated outside the data frame context. This is to prevent
accidental matching of data frame variables when you refer to
variables from the calling context.
}

\section{Methods}{

This function is a \strong{generic}, which means that packages can provide
implementations (methods) for other classes. See the documentation of
individual methods for extra arguments and differences in behaviour.

The following methods are currently available in loaded packages:
\Sexpr[stage=render,results=rd]{dplyr:::methods_rd("select")}.
}

\examples{
iris <- as_tibble(iris) # so it prints a little nicer
select(iris, starts_with("Petal"))
select(iris, ends_with("Width"))
select(iris, !starts_with("Petal"))
select(iris, starts_with("Petal") & ends_with("Width"))
select(iris, is.numeric)

# If desired, you can rename individual variables as you select them
select(iris, species = Species, width = Petal.Width, length = Petal.Length)

df <- as.data.frame(matrix(runif(100), nrow = 10))
df <- as_tibble(df[c(3, 4, 7, 1, 9, 8, 5, 2, 6, 10)])
select(df, V4:V6)
select(df, num_range("V", 4:6))

# Select the grouping variables:
starwars \%>\% group_by(gender) \%>\% select(group_cols())

# Moving variables around --------------------------
# As of dplyr 1.0.0, use relocate(), not select():
relocate(iris, Species, .before = 1)
relocate(iris, Sepal.Length, .after = last_col())
}
\seealso{
Other single table verbs: 
\code{\link{arrange}()},
\code{\link{filter}()},
\code{\link{mutate}()},
\code{\link{rename}()},
\code{\link{slice}()},
\code{\link{summarise}()}
}
\concept{single table verbs}
