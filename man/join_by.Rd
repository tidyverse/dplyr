% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/join-by.R
\name{join_by}
\alias{join_by}
\title{Join specifications}
\usage{
join_by(...)
}
\arguments{
\item{...}{Expressions specifying the join.

Each expression should consist of either a join condition or a join helper:
\itemize{
\item Join conditions: \code{==}, \code{>=}, \code{>}, \code{<=}, or \code{<}.
\item Rolling helpers: \code{preceding()} or \code{following()}.
\item Overlap helpers: \code{between()}, \code{within()}, or \code{overlaps()}.
}

Column names should be specified as quoted or unquoted names. By default,
the name on the left-hand side of a join condition refers to the left-hand
table, unless overriden by explicitly prefixing the column name with either
\verb{x$} or \verb{y$}.

If a single column name is provided without any join conditions, it is
interpreted as if that column name was duplicated on each side of \code{==},
i.e. \code{x} is interpreted as \code{x == x}.}
}
\description{
\code{join_by()} constructs a specification that describes how to join two tables
using a small domain specific language. The result can be supplied as the
\code{by} argument to any of the join functions (such as \code{\link[=left_join]{left_join()}}).

\code{join_by()} is constructed from a comma-separated set of expressions that
are generally of the form \verb{x_col OP y_col}, where \code{OP} is one of \code{==},
\code{>=}, \code{>}, \code{<=}, or \code{<}. These are described in detail below, along with
additional modifiers that are used to perform rolling and overlap joins.

Multiple expressions are combined using an "and" operation in the order
they are specified.
\subsection{Equi joins:}{

Equi joins match on equality, and are the most common type of join. To
construct an equi join, supply two column names to join with separated by
\code{==}. Alternatively, supplying a single name will be interpreted as an equi
join between two columns of the same name. For example, \code{join_by(x)} is
equivalent to \code{join_by(x == x)}.
}

\subsection{Non-equi joins:}{

Non-equi joins match on an inequality, and are common in time series analysis
and genomics. To construct a non-equi join, supply two column names separated
by \code{>}, \code{>=}, \code{<}, or \code{<=}.

Note that non-equi joins will match a single row in \code{x} to a potentially
large number of rows in \code{y}. Be extra careful when constructing non-equi
join specifications!
}

\subsection{Rolling joins:}{

Rolling joins are a variant of a non-equi join that limit the results
returned from the non-equi join condition. They are useful for "rolling"
the preceding value forward or the following value backwards when there
isn't an exact match. There are two helpers that \code{join_by()} recognizes
to assist with constructing rolling joins.
\itemize{
\item \code{preceding(x, y, ..., inclusive = TRUE)}

For each value in \code{x}, this finds the value in \code{y} that is directly
preceding it. If \code{inclusive = TRUE}, an exact match is allowed to count as
the preceding value.

Technically, this finds all matches using the binary condition \code{x >= y},
then filters those matches to only include the one corresponding to the
maximum value of \code{y} (i.e. the preceding match). If \code{inclusive = FALSE},
\code{>=} is replaced with \code{>}.

Dots are for future extensions and must be empty.
\item \code{following(x, y, ..., inclusive = TRUE)}

For each value in \code{x}, this finds the value in \code{y} that is directly
following it. If \code{inclusive = TRUE}, an exact match is allowed to count as
the following value.

Technically, this finds all matches using the binary condition \code{x <= y},
then filters those matches to only include the one corresponding to the
minimum value of \code{y} (i.e. the following match). If \code{inclusive = FALSE},
\code{<=} is replaced with \code{<}.

Dots are for future extensions and must be empty.
}

Unlike other join helpers, the \code{x} argument must reference the left-hand
table (\code{x}) and the \code{y} argument must reference the right-hand table (\code{y}).
Attempting something like \code{preceding(y$a, x$b)} is not defined and will
result in an error.

Rolling joins can't be constructed directly from binary conditions, but are
approximately equivalent to applying the binary condition mentioned above
followed by a \code{filter()} for only the maximum or minimum \code{y} value.
}

\subsection{Overlap joins:}{

Overlap joins are a special case of a non-equi join generally involving one
or two columns from the left-hand table \emph{overlapping} a range computed from
two columns from the right-hand table. There are three helpers that
\code{join_by()} recognizes to assist with constructing overlap joins, all of
which can be constructed from simpler binary expressions.
\itemize{
\item \code{between(x, y_lower, y_upper)}

For each value in \code{x}, this finds everywhere that value falls between
\verb{[y_lower, y_upper]}. Equivalent to \verb{x >= y_lower, x <= y_upper}.
\item \code{within(x_lower, x_upper, y_lower, y_upper)}

For each range in \verb{[x_lower, x_upper]}, this finds everywhere that range
falls completely within \verb{[y_lower, y_upper]}. Equivalent to \verb{x_lower >= y_lower, x_upper <= y_upper}.
\item \code{overlaps(x_lower, x_upper, y_lower, y_upper)}

For each range in \verb{[x_lower, x_upper]}, this finds everywhere that range
overlaps \verb{[y_lower, y_upper]} in any capacity. Equivalent to \verb{x_lower <= y_upper, x_upper >= y_lower}.
}

These conditions assume that the ranges are well-formed, i.e.
\code{x_lower <= x_upper}.
}

\subsection{Column referencing:}{

When specifying join conditions, \code{join_by()} assumes that column names on the
left-hand side of the condition refer to the left-hand table (\code{x}), and names
on the right-hand side of the condition refer to the right-hand table (\code{y}).
Occasionally, it is clearer to be able to specify a right-hand table name on
the left-hand side of the condition, and vice versa. To support this, column
names can be prefixed by \verb{x$} or \verb{y$} to explicitly specify which table they
come from.
}
}
\details{
Note that \code{join_by()} does not support arbitrary expressions on each side of
the join condition. For example, \code{join_by(sales_date - 40 >= promo_date)} is not allowed. To perform a join like this, pre-compute
\code{sales_date - 40} and store it in a separate column, like \code{sales_date_lower},
and refer to that column by name in \code{join_by()}.
}
\examples{
sales <- tibble(
  id = c(1L, 1L, 1L, 2L, 2L),
  sale_date = as.Date(c("2018-12-31", "2019-01-02", "2019-01-05", "2019-01-04", "2019-01-01"))
)
sales

promos <- tibble(
  id = c(1L, 1L, 2L),
  promo_date = as.Date(c("2019-01-01", "2019-01-05", "2019-01-02"))
)
promos

# Match `id` to `id`, and `sale_date` to `promo_date`
by <- join_by(id, sale_date == promo_date)
left_join(sales, promos, by)

# For each `sale_date` within a particular `id`,
# find all `promo_date`s that occurred before that particular sale
by <- join_by(id, sale_date >= promo_date)
left_join(sales, promos, by)

# For each `sale_date` within a particular `id`,
# find only the preceding `promo_date` that occurred directly
# before that sale
by <- join_by(id, preceding(sale_date, promo_date))
left_join(sales, promos, by)

# If you want to disallow exact matching in rolling joins,
# set `inclusive = FALSE`. Note that the promo on `2019-01-05` is no longer
# considered the preceding match for the sale on the same date.
by <- join_by(id, preceding(sale_date, promo_date, inclusive = FALSE))
left_join(sales, promos, by)

# Same as before, but also require that the promo had to occur at most 1
# day before the sale was made. We'll use a full join to see that id 2's
# promo on `2019-01-02` is no longer matched to the sale on `2019-01-04`.
sales <- mutate(sales, sale_date_lower = sale_date - 1)
by <- join_by(id, preceding(sale_date, promo_date), sale_date_lower <= promo_date)
full_join(sales, promos, by)

# ---------------------------------------------------------------------------

segments <- tibble(
  segment_id = 1:4,
  chromosome = c("chr1", "chr2", "chr2", "chr1"),
  start = c(140, 210, 380, 230),
  end = c(150, 240, 415, 280)
)
segments

reference <- tibble(
  reference_id = 1:4,
  chromosome = c("chr1", "chr1", "chr2", "chr2"),
  start = c(100, 200, 300, 400),
  end = c(150, 250, 399, 450)
)
reference

# Find every time a segment `start` falls between the reference
# `[start, end]` range.
by <- join_by(chromosome, between(start, start, end))
full_join(segments, reference, by)

# If you wanted the reference columns first, supply `reference` as `x`
# and `segments` as `y`, then explicitly refer to their columns using `x$`
# and `y$`.
by <- join_by(chromosome, between(y$start, x$start, x$end))
full_join(reference, segments, by)

# Find every time a segment falls completely within a reference.
# Sometimes using `x$` and `y$` makes your intentions clearer, even if they
# match the default behavior.
by <- join_by(chromosome, within(x$start, x$end, y$start, y$end))
inner_join(segments, reference, by)

# Find every time a segment overlaps a reference in any way.
by <- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end))
full_join(segments, reference, by)
}
