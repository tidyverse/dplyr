% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/join-by.R
\name{join_by}
\alias{join_by}
\title{Join specifications}
\usage{
join_by(...)
}
\arguments{
\item{...}{Expressions specifying the join. Each expression should consist
of:
\itemize{
\item A join condition, one of: \code{==}, \code{>}, \code{>=}, \code{<}, or \code{<=}.
\item A quoted or unquoted column name on the left-hand side of the join
condition.
\item A quoted or unquoted column name on the right-hand side of the join
condition.
\item Optionally, the entire join condition can be wrapped in \code{max()} or
\code{min()} to specify a rolling join.
\item If a single column name is provided without any join conditions, it
is interpreted as if that column name was provided on each side of \code{==},
i.e. \code{x} is interpreted as \code{x == x}.
}}
}
\description{
\code{join_by()} constructs a specification to join by using a small domain
specific language. The result can be supplied as the \code{by} argument to any
of the join functions (such as \code{\link[=left_join]{left_join()}}). \code{join_by()} supports
specifications for equi joins, non-equi joins, and rolling joins.
\subsection{Equi Joins:}{

Equi joins match on equality, and are the most common type of join. To
construct an equi join, supply two column names to join with separated by
\code{==}. Alternatively, supplying a single name will be interpreted as an equi
join between two columns of the same name.
}

\subsection{Non-equi Joins:}{

Non-equi joins match on an inequality, and are common in time series analysis
and genomics. To construct a non-equi join, supply two column names separated
by \code{>}, \code{>=}, \code{<}, or \code{<=}.
}

\subsection{Rolling Joins:}{

Rolling joins are a variant of a non-equi join that limit the results
returned from each condition to either the maximum or the minimum of
the matches. To construct a rolling join, wrap a non-equi join condition
in \code{max()} or \code{min()}, such as \code{max(x > y)}.
}
}
\examples{
# "Match id to id, and sales_date to promo_date"
join_by(id, sales_date == promo_date)

# "For each sales_date within a particular id, find all promo_dates that
# occurred before this particular sale"
join_by(id, sales_date >= promo_date)

# "For each sales_date within a particular id, find only the most recent
# promo_date that occurred before this particular sale"
join_by(id, max(sales_date >= promo_date))
}
