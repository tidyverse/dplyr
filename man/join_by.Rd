% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/join-by.R
\name{join_by}
\alias{join_by}
\title{Join specifications}
\usage{
join_by(...)
}
\arguments{
\item{...}{Expressions specifying the join. Each expression should consist
of:
\itemize{
\item A join condition, one of: \code{==}, \code{>}, \code{>=}, \code{<}, or \code{<=}.
\item A quoted or unquoted column name on the left-hand side of the join
condition representing the column to use from \code{x}.
\item A quoted or unquoted column name on the right-hand side of the join
condition representing the column to use from \code{y}.
\item Optionally, the entire join condition can be wrapped in \code{max()} or
\code{min()} to specify a rolling join.
\item If a single column name is provided without any join conditions, it
is interpreted as if that column name was duplicated on each side of
\code{==}, i.e. \code{x} is interpreted as \code{x == x}.
}}
}
\description{
\code{join_by()} constructs a specification to join by using a small domain
specific language. The result can be supplied as the \code{by} argument to any
of the join functions (such as \code{\link[=left_join]{left_join()}}). \code{join_by()} supports
specifications for equi joins, non-equi joins, and rolling joins.
\subsection{Equi Joins:}{

Equi joins match on equality, and are the most common type of join. To
construct an equi join, supply two column names to join with separated by
\code{==}. Alternatively, supplying a single name will be interpreted as an equi
join between two columns of the same name.
}

\subsection{Non-equi Joins:}{

Non-equi joins match on an inequality, and are common in time series analysis
and genomics. To construct a non-equi join, supply two column names separated
by \code{>}, \code{>=}, \code{<}, or \code{<=}.

Note that non-equi joins will match a single row in \code{x} to a potentially
large number of rows in \code{y}. Be extra careful when constructing non-equi
join specifications!
}

\subsection{Rolling Joins:}{

Rolling joins are a variant of a non-equi join that limit the results
returned from each condition to either the maximum or the minimum of
the matches in \code{y}. To construct a rolling join, wrap a non-equi join
condition in \code{max()} or \code{min()}, such as \code{max(x > y)}.
}
}
\details{
Note that \code{join_by()} does not support arbitrary expressions on each side of
the join condition. For example, \code{join_by(sales_date - 40 >= commercial_date)} is not allowed. To perform a join like this, pre-compute
\code{sales_date - 40} and store it in a separate column, like \code{sales_date_lower},
and refer to that column by name in \code{join_by()}.
}
\examples{
sales <- tibble(
 id = c(1L, 1L, 1L, 2L, 2L),
 sale_date = as.Date(c("2018-12-31", "2019-01-02", "2019-01-05", "2019-01-04", "2019-01-01"))
)

promos <- tibble(
 id = c(1L, 1L, 2L),
 promo_date = as.Date(c("2019-01-01", "2019-01-05", "2019-01-02"))
)

# "Match id to id, and sales_date to promo_date"
by <- join_by(id, sale_date == promo_date)
left_join(sales, promos, by)

# "For each sales_date within a particular id, find all promo_dates that
# occurred before this particular sale"
by <- join_by(id, sale_date >= promo_date)
left_join(sales, promos, by)

# "For each sales_date within a particular id, find only the most recent
# promo_date that occurred before this particular sale"
by <- join_by(id, max(sale_date >= promo_date))
left_join(sales, promos, by)

# Same as before, but also require that the promo had to occur at most 1
# day before the sale was made. We'll use a full join to see that id 2's
# promo on `2019-01-02` is no longer matched to the sale on `2019-01-04`.
sales <- mutate(sales, sale_date_lower = sale_date - 1)
by <- join_by(id, max(sale_date >= promo_date), sale_date_lower <= promo_date)
full_join(sales, promos, by)
}
