% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/case-match.R
\name{case_match}
\alias{case_match}
\title{A general vectorised switch}
\usage{
case_match(.x, ..., .default = NULL, .ptype = NULL)
}
\arguments{
\item{.x}{A vector to match against.}

\item{...}{<\code{\link[rlang:dyn-dots]{dynamic-dots}}> A sequence of two-sided
formulas. The left hand side (LHS) determines which values match this case.
The right hand side (RHS) provides the replacement value.

The LHS inputs must evaluate to vectors with the same type as \code{.x}. There
are no restrictions on the size of the LHS inputs, meaning that you can
map multiple values in \code{.x} to the same RHS value.

The RHS inputs will be coerced to their common type. Each RHS input will be
\link[vctrs:vector_recycling_rules]{recycled} to the size of \code{.x}.

\code{NULL} inputs are ignored.}

\item{.default}{The value used when values in \code{.x} aren't matched by any of
the LHS inputs.

\code{.default} is \link[vctrs:vector_recycling_rules]{recycled} to the size of
\code{.x}.

\code{.default} participates in the computation of the common type with the RHS
inputs.

If \code{NULL}, the default, a missing value will be used.}

\item{.ptype}{An optional prototype declaring the desired output type. If
supplied, this overrides the common type of the RHS inputs.}
}
\value{
A vector with the same size as \code{.x} and the same type as the common type of
the RHS inputs in \code{...}.
}
\description{
This function is a variant of \code{\link[=case_when]{case_when()}} that vectorises the idea behind
\code{\link[=switch]{switch()}}. It is an R equivalent of the SQL "simple" \verb{CASE WHEN} statement
that matches using values rather than logical expressions. If no cases match,
a missing value is returned unless a \code{.default} is supplied.
}
\examples{
x <- c("a", "b", "a", "d", "b", NA, "c", "e")

# `case_match()` acts like a vectorized `switch()`.
# Unmatched values "fall through" as a missing value.
case_match(
  x,
  "a" ~ 1,
  "b" ~ 2,
  "c" ~ 3,
  "d" ~ 4
)

# Missing values can be matched exactly, and `.default` can be used to
# control the value used for unmatched values of `.x`
case_match(
  x,
  "a" ~ 1,
  "b" ~ 2,
  "c" ~ 3,
  "d" ~ 4,
  NA ~ 0,
  .default = 100
)

# Input values can be grouped into the same expression to map them to the
# same output value
case_match(
  x,
  c("a", "b") ~ "low",
  c("c", "d", "e") ~ "high"
)

# `.default` is allowed to be vectorized, and you can supply a `.ptype` to
# force a particular output type. Combining these features together allows
# you to create a type stable "replace match" helper.
replace_match <- function(.x, ...) {
  case_match(.x, ..., .default = .x, .ptype = .x)
}

replace_match(x, NA ~ "foo")

starwars \%>\%
  mutate(
    # Replace missings, but leave everything else alone
    hair_color = replace_match(hair_color, NA ~ "unknown"),
    # Replace some, but not all, of the species
    species = replace_match(
      species,
      "Human" ~ "Humanoid",
      "Droid" ~ "Robot",
      c("Wookiee", "Ewok") ~ "Hairy"
    ),
    .keep = "used"
  )
}
\seealso{
\code{\link[=case_when]{case_when()}}
}
