% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/case-match.R
\name{case_match}
\alias{case_match}
\title{A general vectorised switch}
\usage{
case_match(.x, ..., .default = NULL, .ptype = NULL)
}
\arguments{
\item{.x}{A vector to match against.}

\item{...}{<\code{\link[rlang:dyn-dots]{dynamic-dots}}> A sequence of two-sided
formulas. The left hand side (LHS) determines which values match this case.
The right hand side (RHS) provides the replacement value.

The LHS inputs must evaluate to vectors with the same type as \code{.x}. There
are no restrictions on the size of the LHS inputs, meaning that you can
map multiple values in \code{.x} to the same RHS value. If a value in \code{.x} is
matched to multiple LHS inputs, the first match is used.

The RHS inputs will be coerced to their common type. Each RHS input will be
\link[vctrs:vector_recycling_rules]{recycled} to the size of \code{.x}.

\code{NULL} inputs are ignored.}

\item{.default}{The value used when values in \code{.x} aren't matched by any of
the LHS inputs.

\code{.default} is \link[vctrs:vector_recycling_rules]{recycled} to the size of
\code{.x}.

\code{.default} participates in the computation of the common type with the RHS
inputs.

If \code{NULL}, the default, a missing value will be used.}

\item{.ptype}{An optional prototype declaring the desired output type. If
supplied, this overrides the common type of the RHS inputs.}
}
\value{
A vector with the same size as \code{.x} and the same type as the common type of
the RHS inputs in \code{...}.
}
\description{
This function is a variant of \code{\link[=case_when]{case_when()}} that vectorises the idea behind
\code{\link[=switch]{switch()}}. Use this to repeatedly recode one or more values in \code{.x} to a new
value. It is an R equivalent of the SQL "simple" \verb{CASE WHEN} statement that
matches using values rather than logical expressions. If no cases match, a
missing value is returned unless a \code{.default} is supplied.
}
\examples{
x <- c("a", "b", "a", "d", "b", NA, "c", "e")

# `case_match()` acts like a vectorized `switch()`.
# Unmatched values "fall through" as a missing value.
case_match(
  x,
  "a" ~ 1,
  "b" ~ 2,
  "c" ~ 3,
  "d" ~ 4
)

# Missing values can be matched exactly, and `.default` can be used to
# control the value used for unmatched values of `.x`
case_match(
  x,
  "a" ~ 1,
  "b" ~ 2,
  "c" ~ 3,
  "d" ~ 4,
  NA ~ 0,
  .default = 100
)

# Input values can be grouped into the same expression to map them to the
# same output value
case_match(
  x,
  c("a", "b") ~ "low",
  c("c", "d", "e") ~ "high"
)

# `case_match()` isn't limited to character input,
# you can match against any vector type
y <- c(1, 2, 1, 3, 1, NA, 2, 4)

case_match(
  y,
  c(1, 3) ~ "odd",
  c(2, 4) ~ "even",
  .default = "missing"
)

# Setting `.default` to the original vector is a useful way to replace
# selected values, leaving everything else as is
case_match(y, NA ~ 0, .default = y)

starwars \%>\%
  mutate(
    # Replace missings, but leave everything else alone
    hair_color = case_match(hair_color, NA ~ "unknown", .default = hair_color),
    # Replace some, but not all, of the species
    species = case_match(
      species,
      "Human" ~ "Humanoid",
      "Droid" ~ "Robot",
      c("Wookiee", "Ewok") ~ "Hairy",
      .default = species
    ),
    .keep = "used"
  )
}
\seealso{
\code{\link[=case_when]{case_when()}}
}
