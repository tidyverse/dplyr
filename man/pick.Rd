% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pick.R
\name{pick}
\alias{pick}
\title{Select a subset of columns}
\usage{
pick(...)
}
\arguments{
\item{...}{<\code{\link[=dplyr_tidy_select]{tidy-select}}>

Columns to pick. Because \code{pick()} is used within functions like
\code{mutate()} and \code{summarise()}, you can't pick grouping variables.}
}
\value{
A tibble containing the selected columns.
}
\description{
\code{pick()} provides a way to easily select a subset of columns from your data
using \code{select()} semantics while inside a "data-masking" function like
\code{mutate()} or \code{summarise()}.

\code{pick()}'s main purpose is as a tool for easy column selection. Typically,
you compute on the data frame returned by \code{pick()} as a whole, rather than on
each column individually. To apply a function across multiple columns, see
\code{\link[=across]{across()}}.
}
\details{
For \code{pick()}, the tidyselection provided through \code{...} is only evaluated once
on the \emph{original} data frame, and the selection is then reused for all
groups. This allows \code{pick()} to enforce two important invariants:
\itemize{
\item The columns selected by \code{pick()} are the same across all groups.
\item The number of rows returned by \code{pick()} is always equal to the number of
rows in the current group.
}

For \code{rowwise()} data frames, list-columns are returned as they appear in the
original data frame. This ensures that they can be \code{pick()}-ed alongside
other columns.
}
\examples{
df <- tibble(
  x = c(3, 2, 2, 2, 1),
  y = c(0, 2, 1, 1, 4),
  z = c("a", "a", "a", "b", "a")
)
df

# `pick()` provides a way to select a subset of your columns using
# tidyselect. It returns a data frame.
df \%>\% mutate(cols = pick(y, z))

# This is useful for functions that take data frames as inputs.
# For example, you can compute a joint rank between `x` and `y`.
df \%>\% mutate(rank = dense_rank(pick(x, y)))

# Or compute a consecutive id column based off `x` and `z` that increments
# any time a value changes in either column
df \%>\% mutate(id = consecutive_id(pick(x, z))) \%>\% select(id, x, z)

# `pick()` is also useful as a way to augment "data-masking" functions with
# `select()` (i.e. tidyselect) semantics. For example, you can use `pick()`
# to create a wrapper around `group_by()` that takes a tidyselection of
# columns to group on.
my_group_by <- function(data, cols) {
  group_by(data, pick({{ cols }}))
}

my_group_by(df, c(x, z))
}
\seealso{
\code{\link[=across]{across()}}
}
