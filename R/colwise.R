#' Summarise and mutate multiple columns.
#'
#' `summarise_all()` and `mutate_all()` apply the functions
#' to all (non-grouping) columns. `summarise_at()` and
#' `mutate_at()` allow you to select columns
#' using the same name-based [select_helpers] as with
#' [select()]. `summarise_if`() and
#' `mutate_if`() operate on columns for which a predicate returns
#' `TRUE`. Finally, [summarise_each()] and
#' [mutate_each()] are older variants that will be
#' deprecated in the future.
#'
#' @param .tbl a tbl
#' @param .funs List of function calls generated by
#'   [funs()], or a character vector of function names, or
#'   simply a function (only for local sources).
#' @param .cols A list of columns generated by [vars()],
#'   or a character vector of column names, or a numeric vector of column
#'   positions.
#' @param .predicate A predicate function to be applied to the columns
#'   or a logical vector. The columns for which `.predicate` is
#'   or returns `TRUE` will be summarised or mutated.
#' @param ... Additional arguments for the function calls. These are
#'   evaluated only once.
#' @return A data frame. By default, the newly created columns have the shortest
#'   names needed to distinguish the output. To force inclusion of a name,
#'   even when not needed, name the input (see examples for details).
#' @seealso [vars()], [funs()]
#' @examples
#' by_species <- iris %>% group_by(Species)
#'
#' # One function
#' by_species %>% summarise_all(n_distinct)
#' by_species %>% summarise_all(mean)
#'
#' # Use the _at and _if variants for conditional mapping.
#' by_species %>% summarise_if(is.numeric, mean)
#'
#' # summarise_at() can use select() helpers with the vars() function:
#' by_species %>% summarise_at(vars(Petal.Width), mean)
#' by_species %>% summarise_at(vars(matches("Width")), mean)
#'
#' # You can also specify columns with column names or column positions:
#' by_species %>% summarise_at(c("Sepal.Width", "Petal.Width"), mean)
#' by_species %>% summarise_at(c(1, 3), mean)
#'
#' # You can provide additional arguments. Those are evaluated only once:
#' by_species %>% summarise_all(mean, trim = 1)
#' by_species %>% summarise_at(vars(Petal.Width), mean, trim = 1)
#'
#' # You can provide an expression or multiple functions with the funs() helper.
#' by_species %>% mutate_all(funs(. * 0.4))
#' by_species %>% summarise_all(funs(min, max))
#' # Note that output variable name must now include function name, in order to
#' # keep things distinct.
#'
#' # Function names will be included if .funs has names or whenever multiple
#' # functions are used.
#' by_species %>% mutate_all(funs("in" = . / 2.54))
#' by_species %>% mutate_all(funs(rg = diff(range(.))))
#' by_species %>% summarise_all(funs(med = median))
#' by_species %>% summarise_all(funs(Q3 = quantile), probs = 0.75)
#' by_species %>% summarise_all(c("min", "max"))
#'
#' # Two functions, continued
#' by_species %>% summarise_at(vars(Petal.Width, Sepal.Width), funs(min, max))
#' by_species %>% summarise_at(vars(matches("Width")), funs(min, max))
#'
#' @aliases summarise_each_q mutate_each_q
#' @export
summarise_all <- function(.tbl, .funs, ...) {
  vars <- list(~everything())
  funs <- as_fun_list(.funs, enquo(.funs), ...)
  funs <- apply_vars(funs, vars, .tbl)
  summarise(.tbl, !!! funs)
}

#' @rdname summarise_all
#' @export
mutate_all <- function(.tbl, .funs, ...) {
  vars <- list(~everything())
  funs <- as_fun_list(.funs, enquo(.funs), ...)
  funs <- apply_vars(funs, vars, .tbl)
  mutate(.tbl, !!! funs)
}

#' @rdname summarise_all
#' @export
summarise_if <- function(.tbl, .predicate, .funs, ...) {
  vars <- tbl_if_syms(.tbl, .predicate)
  funs <- as_fun_list(.funs, enquo(.funs), ...)
  funs <- apply_vars(funs, vars, .tbl)
  summarise(.tbl, !!! funs)
}

#' @rdname summarise_all
#' @export
mutate_if <- function(.tbl, .predicate, .funs, ...) {
  vars <- tbl_if_syms(.tbl, .predicate)
  funs <- as_fun_list(.funs, enquo(.funs), ...)
  funs <- apply_vars(funs, vars, .tbl)
  mutate(.tbl, !!! funs)
}

#' @rdname summarise_all
#' @export
summarise_at <- function(.tbl, .cols, .funs, ...) {
  vars <- tbl_at_syms(.tbl, .cols)
  funs <- as_fun_list(.funs, enquo(.funs), ...)
  funs <- apply_vars(funs, vars, .tbl)
  summarise(.tbl, !!! funs)
}

#' @rdname summarise_all
#' @export
mutate_at <- function(.tbl, .cols, .funs, ...) {
  vars <- tbl_at_syms(.tbl, .cols)
  funs <- as_fun_list(.funs, enquo(.funs), ...)
  funs <- apply_vars(funs, vars, .tbl)
  mutate(.tbl, !!! funs)
}

#' @rdname summarise_all
#' @export
summarize_all <- summarise_all

#' @rdname summarise_all
#' @export
summarize_at <- summarise_at

#' @rdname summarise_all
#' @export
summarize_if <- summarise_if

#' Select columns
#'
#' This helper has equivalent semantics to [select()]. Its
#' purpose is to provide `select()` semantics to the colwise
#' summarising and mutating verbs.
#' @param ... Variables to include/exclude in mutate/summarise. You
#'   can use same specifications as in [select()]. If
#'   missing, defaults to all non-grouping variables.
#' @seealso [summarise_all()]
#' @export
vars <- function(...) {
  structure(quos(...), class = "col_list")
}
is_col_list <- function(cols) inherits(cols, "col_list")

# Requires tbl_vars() method
tbl_at_syms <- function(tbl, cols) {
  vars <- tbl_vars(tbl)

  if (is_character(cols)) {
    selected <- syms(cols)
  } else if (is_col_list(cols)) {
    selected <- cols
  } else if (is.numeric(cols)) {
    selected <- syms(vars[cols])
  } else {
    abort("`.cols` should be a character/numeric vector or a columns object")
  }

  selected
}

# Requires tbl_vars(), `[[`() and length() methods
tbl_if_syms <- function(tbl, p, ...) {
  vars <- tbl_vars(tbl)

  if (is_logical(p)) {
    stopifnot(length(p) == length(vars))
    return(syms(vars[p]))
  }

  if (inherits(tbl, "tbl_lazy")) {
    inform("Applying predicate on the first 100 rows")
    tibble <- collect(tbl, n = 100)
  } else {
    tibble <- tbl
  }

  n <- length(tibble)
  selected <- lgl_len(n)
  for (i in seq_len(n)) {
    selected[[i]] <- p(tibble[[i]], ...)
  }

  vars <- vars[selected]
  syms(vars)
}

apply_vars <- function(funs, vars, tbl) {
  stopifnot(is_fun_list(funs))

  named_calls <- attr(funs, "have_name")
  named_vars <- any(have_name(vars))
  vars <- select_vars(tbl_vars(tbl), !!! vars, exclude = group_vars(tbl))

  out <- vector("list", length(vars) * length(funs))
  dim(out) <- c(length(vars), length(funs))

  for (i in seq_along(vars)) {
    for (j in seq_along(funs)) {
      var_sym <- sym(vars[[i]])
      out[[i, j]] <- expr_substitute(funs[[j]], quote(.), var_sym)
    }
  }
  dim(out) <- NULL

  if (length(funs) == 1 && !named_calls) {
    names(out) <- names(vars)
  } else if (length(vars) == 1 && !named_vars) {
    names(out) <- names(funs)
  } else {
    grid <- expand.grid(var = names(vars), call = names(funs))
    names(out) <- paste(grid$var, grid$call, sep = "_")
  }

  out
}

#' Summarise and mutate multiple columns.
#'
#' Apply one or more functions to one or more columns. Grouping variables
#' are always excluded from modification.
#'
#' `mutate_each()` and `summarise_each()` are deprecated in favour of
#' a more featureful family of functions: [mutate_all()],
#' [mutate_at()], [mutate_if()], [summarise_all()], [summarise_at()]
#' and [summarise_if()].
#' @param tbl a tbl
#' @param funs List of function calls, generated by [funs()], or
#'   a character vector of function names.
#' @param ... Variables to include/exclude in mutate/summarise.
#'   You can use same specifications as in [select()]. If missing,
#'   defaults to all non-grouping variables.
#'
#'   For standard evaluation versions (ending in `_`) these can
#'   be either a list of expressions or a character vector.
#' @export
summarise_each <- function(tbl, funs, ...) {
  summarise_each_(tbl, funs, quos(...))
}

#' @export
#' @rdname se-deprecated
#' @inheritParams summarise_each
summarise_each_ <- function(tbl, funs, vars) {
  .Deprecated("summarise_all")
  if (is_empty(vars)) {
    vars <- list(~everything())
  } else {
    vars <- compat_lazy_dots(vars, caller_env())
  }
  if (is_character(funs)) {
    funs <- funs_(funs)
  }

  funs <- apply_vars(funs, vars, tbl)
  summarise(tbl, !!! funs)
}

#' @rdname summarise_each
#' @export
summarize_each <- summarise_each

#' @rdname se-deprecated
#' @export
summarize_each_ <- summarise_each_

#' @export
#' @rdname summarise_each
mutate_each <- function(tbl, funs, ...) {
  if (is_character(funs)) {
    funs <- funs_(funs)
  }

  mutate_each_(tbl, funs, quos(...))
}

#' @export
#' @rdname se-deprecated
mutate_each_ <- function(tbl, funs, vars) {
  .Deprecated("mutate_all")
  if (is_empty(vars)) {
    vars <- list(~everything())
  } else {
    vars <- compat_lazy_dots(vars, caller_env())
  }
  funs <- apply_vars(funs, vars, tbl)
  mutate(tbl, !!! funs)
}


#' @export
summarise_each_q <- function(...) {
  .Deprecated("summarise_all")
  summarise_each_(...)
}
#' @export
mutate_each_q <- function(...) {
  .Deprecated("mutate_all")
  mutate_each_(...)
}
