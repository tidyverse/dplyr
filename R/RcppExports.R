# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

loc <- function(data) {
    .Call(`_dplyr_loc`, data)
}

dfloc <- function(df) {
    .Call(`_dplyr_dfloc`, df)
}

plfloc <- function(data) {
    .Call(`_dplyr_plfloc`, data)
}

strings_addresses <- function(s) {
    .Call(`_dplyr_strings_addresses`, s)
}

#' Enable internal logging
#'
#' Log entries, depending on the log level, will be printed to the standard
#' error stream.
#'
#' @param log_level A character value, one of "WARN", "INFO", "DEBUG", "VERB",
#'   or "NONE".
#'
#' @keywords internal
init_logging <- function(log_level) {
    invisible(.Call(`_dplyr_init_logging`, log_level))
}

is_maybe_shared <- function(env, name) {
    .Call(`_dplyr_is_maybe_shared`, env, name)
}

maybe_shared_columns <- function(df) {
    .Call(`_dplyr_maybe_shared_columns`, df)
}

arrange_impl <- function(df, quosures, frame) {
    .Call(`_dplyr_arrange_impl`, df, quosures, frame)
}

#' Do values in a numeric vector fall in specified range?
#'
#' This is a shortcut for `x >= left & x <= right`, implemented
#' efficiently in C++ for local values, and translated to the
#' appropriate SQL for remote tables.
#'
#' @param x A numeric vector of values
#' @param left,right Boundary values
#' @export
#' @examples
#' between(1:12, 7, 9)
#'
#' x <- rnorm(1e2)
#' x[between(x, -1, 1)]
between <- function(x, left, right) {
    .Call(`_dplyr_between`, x, left, right)
}

flatten_bindable <- function(x) {
    .Call(`_dplyr_flatten_bindable`, x)
}

bind_rows_ <- function(dots, id) {
    .Call(`_dplyr_bind_rows_`, dots, id)
}

cbind_all <- function(dots) {
    .Call(`_dplyr_cbind_all`, dots)
}

combine_all <- function(data) {
    .Call(`_dplyr_combine_all`, data)
}

distinct_impl <- function(df, vars, keep, frame) {
    .Call(`_dplyr_distinct_impl`, df, vars, keep, frame)
}

n_distinct_multi <- function(variables, na_rm = FALSE) {
    .Call(`_dplyr_n_distinct_multi`, variables, na_rm)
}

filter_impl <- function(df, quo) {
    .Call(`_dplyr_filter_impl`, df, quo)
}

slice_impl <- function(df, quosure) {
    .Call(`_dplyr_slice_impl`, df, quosure)
}

grouped_indices_grouped_df_impl <- function(gdf) {
    .Call(`_dplyr_grouped_indices_grouped_df_impl`, gdf)
}

group_size_grouped_cpp <- function(gdf) {
    .Call(`_dplyr_group_size_grouped_cpp`, gdf)
}

regroup <- function(grouping_data, frame) {
    .Call(`_dplyr_regroup`, grouping_data, frame)
}

grouped_df_impl <- function(data, symbols) {
    .Call(`_dplyr_grouped_df_impl`, data, symbols)
}

group_data_grouped_df <- function(data) {
    .Call(`_dplyr_group_data_grouped_df`, data)
}

ungroup_grouped_df <- function(df) {
    .Call(`_dplyr_ungroup_grouped_df`, df)
}

group_split_impl <- function(gdf, keep, frame, ptype) {
    .Call(`_dplyr_group_split_impl`, gdf, keep, frame, ptype)
}

hybrids <- function() {
    .Call(`_dplyr_hybrids`)
}

semi_join_impl <- function(x, y, by_x, by_y, na_match, frame) {
    .Call(`_dplyr_semi_join_impl`, x, y, by_x, by_y, na_match, frame)
}

anti_join_impl <- function(x, y, by_x, by_y, na_match, frame) {
    .Call(`_dplyr_anti_join_impl`, x, y, by_x, by_y, na_match, frame)
}

inner_join_impl <- function(x, y, by_x, by_y, aux_x, aux_y, na_match, frame) {
    .Call(`_dplyr_inner_join_impl`, x, y, by_x, by_y, aux_x, aux_y, na_match, frame)
}

nest_join_impl <- function(x, y, by_x, by_y, aux_y, yname, frame) {
    .Call(`_dplyr_nest_join_impl`, x, y, by_x, by_y, aux_y, yname, frame)
}

left_join_impl <- function(x, y, by_x, by_y, aux_x, aux_y, na_match, frame) {
    .Call(`_dplyr_left_join_impl`, x, y, by_x, by_y, aux_x, aux_y, na_match, frame)
}

right_join_impl <- function(x, y, by_x, by_y, aux_x, aux_y, na_match, frame) {
    .Call(`_dplyr_right_join_impl`, x, y, by_x, by_y, aux_x, aux_y, na_match, frame)
}

full_join_impl <- function(x, y, by_x, by_y, aux_x, aux_y, na_match, frame) {
    .Call(`_dplyr_full_join_impl`, x, y, by_x, by_y, aux_x, aux_y, na_match, frame)
}

mutate_impl <- function(df, dots) {
    .Call(`_dplyr_mutate_impl`, df, dots)
}

select_impl <- function(df, vars) {
    .Call(`_dplyr_select_impl`, df, vars)
}

compatible_data_frame_nonames <- function(x, y, convert) {
    .Call(`_dplyr_compatible_data_frame_nonames`, x, y, convert)
}

compatible_data_frame <- function(x, y, ignore_col_order = TRUE, convert = FALSE) {
    .Call(`_dplyr_compatible_data_frame`, x, y, ignore_col_order, convert)
}

equal_data_frame <- function(x, y, ignore_col_order = TRUE, ignore_row_order = TRUE, convert = FALSE) {
    .Call(`_dplyr_equal_data_frame`, x, y, ignore_col_order, ignore_row_order, convert)
}

union_data_frame <- function(x, y) {
    .Call(`_dplyr_union_data_frame`, x, y)
}

intersect_data_frame <- function(x, y) {
    .Call(`_dplyr_intersect_data_frame`, x, y)
}

setdiff_data_frame <- function(x, y) {
    .Call(`_dplyr_setdiff_data_frame`, x, y)
}

summarise_impl <- function(df, dots, frame) {
    .Call(`_dplyr_summarise_impl`, df, dots, frame)
}

hybrid_impl <- function(df, quosure) {
    .Call(`_dplyr_hybrid_impl`, df, quosure)
}

test_comparisons <- function() {
    .Call(`_dplyr_test_comparisons`)
}

test_matches <- function() {
    .Call(`_dplyr_test_matches`)
}

test_length_wrap <- function() {
    .Call(`_dplyr_test_length_wrap`)
}

materialize_binding <- function(idx, mask_proxy_xp) {
    .Call(`_dplyr_materialize_binding`, idx, mask_proxy_xp)
}

check_valid_names <- function(names, warn_only = FALSE) {
    invisible(.Call(`_dplyr_check_valid_names`, names, warn_only))
}

assert_all_allow_list <- function(data) {
    invisible(.Call(`_dplyr_assert_all_allow_list`, data))
}

is_data_pronoun <- function(expr) {
    .Call(`_dplyr_is_data_pronoun`, expr)
}

is_variable_reference <- function(expr) {
    .Call(`_dplyr_is_variable_reference`, expr)
}

quo_is_variable_reference <- function(quo) {
    .Call(`_dplyr_quo_is_variable_reference`, quo)
}

quo_is_data_pronoun <- function(quo) {
    .Call(`_dplyr_quo_is_data_pronoun`, quo)
}

#' Cumulativate versions of any, all, and mean
#'
#' dplyr provides `cumall()`, `cumany()`, and `cummean()` to complete R's set
#' of cumulative functions.
#'
#' @section Cumulative logical functions:
#'
#' These are particularly useful in conjunction with `filter()`:
#'
#' * `cumall(x)`: all cases until the first `FALSE`.
#' * `cumall(!x)`: all cases until the first `TRUE`.
#' * `cumany(x)`: all cases after the first `TRUE`.
#' * `cumany(!x)`: all cases after the first `FALSE`.
#'
#' @param x For `cumall()` and `cumany()`, a logical vector; for
#'   `cummean()` an integer or numeric vector.
#' @return A vector the same length as `x`.
#' @export
#' @examples
#' # `cummean()` returns a numeric/integer vector of the same length
#' # as the input vector.
#' x <- c(1, 3, 5, 2, 2)
#' cummean(x)
#' cumsum(x) / seq_along(x)
#'
#' # `cumall()` and `cumany()` return logicals
#' cumall(x < 5)
#' cumany(x == 3)
#'
#' # `cumall()` vs. `cumany()`
#' df <- data.frame(
#'   date = as.Date("2020-01-01") + 0:6,
#'   balance = c(100, 50, 25, -25, -50, 30, 120)
#' )
#' # all rows after first overdraft
#' df %>% filter(cumany(balance < 0))
#' # all rows until first overdraft
#' df %>% filter(cumall(!(balance < 0)))
cumall <- function(x) {
    .Call(`_dplyr_cumall`, x)
}

#' @export
#' @rdname cumall
cumany <- function(x) {
    .Call(`_dplyr_cumany`, x)
}

#' @export
#' @rdname cumall
cummean <- function(x) {
    .Call(`_dplyr_cummean`, x)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('_dplyr_RcppExport_registerCCallable', PACKAGE = 'dplyr')
})
