# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

loc <- function(data) {
    .Call('dplyr_loc', PACKAGE = 'dplyr', data)
}

dfloc <- function(df) {
    .Call('dplyr_dfloc', PACKAGE = 'dplyr', df)
}

plfloc <- function(data) {
    .Call('dplyr_plfloc', PACKAGE = 'dplyr', data)
}

arrange_impl <- function(data, args, dots) {
    .Call('dplyr_arrange_impl', PACKAGE = 'dplyr', data, args, dots)
}

#' Do values in a numeric vector fail in specified range?
#'
#' This is a shortcut for \code{x >= left & x <= right}, implemented
#' efficiently in C++ for local values, and translated to the
#' appropriate SQL for remote tables.
#'
#' @param x A numeric vector of values
#' @param left,right Boundary values
#' @export
#' @examples
#' x <- rnorm(1e2)
#' x[between(x, -1, 1)]
between <- function(x, left, right) {
    .Call('dplyr_between', PACKAGE = 'dplyr', x, left, right)
}

#' @export
#' @rdname rbind
rbind_all <- function(dots) {
    .Call('dplyr_rbind_all', PACKAGE = 'dplyr', dots)
}

rbind_list__impl <- function(dots) {
    .Call('dplyr_rbind_list__impl', PACKAGE = 'dplyr', dots)
}

cbind_list__impl <- function(dots) {
    .Call('dplyr_cbind_list__impl', PACKAGE = 'dplyr', dots)
}

cbind_all <- function(dots) {
    .Call('dplyr_cbind_all', PACKAGE = 'dplyr', dots)
}

distinct_impl <- function(df) {
    .Call('dplyr_distinct_impl', PACKAGE = 'dplyr', df)
}

semi_join_impl <- function(x, y, by) {
    .Call('dplyr_semi_join_impl', PACKAGE = 'dplyr', x, y, by)
}

anti_join_impl <- function(x, y, by) {
    .Call('dplyr_anti_join_impl', PACKAGE = 'dplyr', x, y, by)
}

inner_join_impl <- function(x, y, by) {
    .Call('dplyr_inner_join_impl', PACKAGE = 'dplyr', x, y, by)
}

left_join_impl <- function(x, y, by) {
    .Call('dplyr_left_join_impl', PACKAGE = 'dplyr', x, y, by)
}

right_join_impl <- function(x, y, by) {
    .Call('dplyr_right_join_impl', PACKAGE = 'dplyr', x, y, by)
}

shallow_copy <- function(data) {
    .Call('dplyr_shallow_copy', PACKAGE = 'dplyr', data)
}

compatible_data_frame <- function(x, y, ignore_col_order = TRUE, convert = FALSE) {
    .Call('dplyr_compatible_data_frame', PACKAGE = 'dplyr', x, y, ignore_col_order, convert)
}

equal_data_frame <- function(x, y, ignore_col_order = TRUE, ignore_row_order = TRUE, convert = FALSE) {
    .Call('dplyr_equal_data_frame', PACKAGE = 'dplyr', x, y, ignore_col_order, ignore_row_order, convert)
}

all_equal_data_frame <- function(args, env) {
    .Call('dplyr_all_equal_data_frame', PACKAGE = 'dplyr', args, env)
}

union_data_frame <- function(x, y) {
    .Call('dplyr_union_data_frame', PACKAGE = 'dplyr', x, y)
}

intersect_data_frame <- function(x, y) {
    .Call('dplyr_intersect_data_frame', PACKAGE = 'dplyr', x, y)
}

setdiff_data_frame <- function(x, y) {
    .Call('dplyr_setdiff_data_frame', PACKAGE = 'dplyr', x, y)
}

match_data_frame <- function(x, y) {
    .Call('dplyr_match_data_frame', PACKAGE = 'dplyr', x, y)
}

grouped_df_impl <- function(data, symbols, drop) {
    .Call('dplyr_grouped_df_impl', PACKAGE = 'dplyr', data, symbols, drop)
}

grouped_df_adj_impl <- function(data, symbols, drop) {
    .Call('dplyr_grouped_df_adj_impl', PACKAGE = 'dplyr', data, symbols, drop)
}

integer_filter_impl <- function(df, args, env) {
    .Call('dplyr_integer_filter_impl', PACKAGE = 'dplyr', df, args, env)
}

mutate_impl <- function(df, args, env) {
    .Call('dplyr_mutate_impl', PACKAGE = 'dplyr', df, args, env)
}

order_impl <- function(args, env) {
    .Call('dplyr_order_impl', PACKAGE = 'dplyr', args, env)
}

sort_impl <- function(data) {
    .Call('dplyr_sort_impl', PACKAGE = 'dplyr', data)
}

group_size_grouped_cpp <- function(gdf) {
    .Call('dplyr_group_size_grouped_cpp', PACKAGE = 'dplyr', gdf)
}

#' Efficiently count the number of unique values in a vector.
#'
#' This is a faster and more concise equivalent of \code{length(unique(x))}
#'
#' @param x a vector of values
#' @export
#' @examples
#' x <- sample(1:10, 1e5, rep = TRUE)
#' length(unique(x))
#' n_distinct(x)
n_distinct <- function(x) {
    .Call('dplyr_n_distinct', PACKAGE = 'dplyr', x)
}

as_regular_df <- function(df) {
    .Call('dplyr_as_regular_df', PACKAGE = 'dplyr', df)
}

ungroup_grouped_df <- function(df) {
    .Call('dplyr_ungroup_grouped_df', PACKAGE = 'dplyr', df)
}

tbl_df_impl <- function(df) {
    .Call('dplyr_tbl_df_impl', PACKAGE = 'dplyr', df)
}

split_indices <- function(group, groups) {
    .Call('dplyr_split_indices', PACKAGE = 'dplyr', group, groups)
}

filter_impl <- function(df, args, env) {
    .Call('dplyr_filter_impl', PACKAGE = 'dplyr', df, args, env)
}

select_impl <- function(df, vars) {
    .Call('dplyr_select_impl', PACKAGE = 'dplyr', df, vars)
}

summarise_impl <- function(df, args, env) {
    .Call('dplyr_summarise_impl', PACKAGE = 'dplyr', df, args, env)
}

test_comparisons <- function() {
    .Call('dplyr_test_comparisons', PACKAGE = 'dplyr')
}

#' Cumulativate versions of any, all, and mean
#'
#' dplyr adds \code{cumall}, \code{cumany}, and \code{cummean} to complete
#' R's set of cumulate functions to match the aggregation functions available
#' in most databases
#'
#' @param x For \code{cumall} & \code{cumany}, a logical vector; for
#'   \code{cummean} an integer or numeric vector
#' @export
cumall <- function(x) {
    .Call('dplyr_cumall', PACKAGE = 'dplyr', x)
}

#' @export
#' @rdname cumall
cumany <- function(x) {
    .Call('dplyr_cumany', PACKAGE = 'dplyr', x)
}

#' @export
#' @rdname cumall
cummean <- function(x) {
    .Call('dplyr_cummean', PACKAGE = 'dplyr', x)
}

