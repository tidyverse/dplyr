---
title: "Programming with dplyr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Programming with dplyr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
set.seed(1014)
```

Most dplyr verbs use **tidy evaluation** in some way. Tidy evaluation is a special type of non-standard evaluation used throughout the tidyverse. There are two basic forms found in dplyr:

* `arrange()`, `filter()`, `group_by()`, `mutate()`, and `summarise()` use 
  **data masking** so that you can use data variables as if they were variables 
  in the environment (i.e. you write `my_variable` not `df$myvariable`). 

* `across()`, `relocate()`, `rename()`, `select()`, and `pull()` use 
  **tidy selection** so you can easily choose variabe based on their position, 
  name, or type (e.g. `starts_with("x")` or `is.numeric`).

Data masking and tidy selection make interactive data exploration fast and fluid, but add some new challenges when you attempt to use them indirectly, as in a for loop or function. This vignette shows you how to overcome those challenges.

```{r, message = FALSE}
library(dplyr)
```

## Key ideas

### Data masking and the two meanings of "variable"

Data masking allows your data manipulation code to be more succinct because you don't need to repeat the name of the data frame. For example, you can write `filter(df, x == 1, y == 2, z == 3)` instead of `df[df$x == 1 & df$y ==2 & df$z == 3, ]`. Unfortunately this benefit does not come for free. It's harder to use  indirection: how do you store the "name" of variable inside another variable so you can write a function or for loop? 

The key idea that makes data masking is that it blurs the line between the two different ways we use "variable":

* __env-variables__ are "programming" variables that live in an environment.
  They are usually created with `<-`. 

* __data-variables__ are "statistical" variables that live in a data frame.
  They usually come from data files (e.g. `.csv`, `.xls`), or are created 
  manipulating existing variables. 
  
Take this piece of code:

```{r}
df <- data.frame(x = runif(3), y = runif(3))
df$x
```

It creates a env-variable called `df`, that contains two data-variables, `x` and `y`. Then it extracts the data-variable `x` out of the data frame `df` using `$`.

Tidy evaluation makes it easier to write data analysis code because it blurs the distinction between the two types of variables, allowing you to refer to data-variables without any additional syntax. In most (but not all) base R functions you need to refer to a data-variable with `$`, leading to code that repeats the name of the data frame many times:

```{r, results = FALSE}
starwars[starwars$homeworld == "Naboo" & starwars$species == "Human", ,]
```

The dplyr equivalent of this code is more concise because you can refer to data-variables as if they were env-variables:

```{r, results = FALSE}
starwars %>% filter(homeworld == "Naboo", species == "Human")
```

(dplyr's `filter()` is inspired by base R's `subset()`. `subset()` provides data masking, but not with tidy evaluation, so unfortunately the same techniques don't apply to it.)

You usually use dplyr verbs purely with data-vars, but they work equally well with env-vars:

```{r, results = FALSE}
planet <- "Naboo"
starwars %>% filter(homeworld == planet)
```

I think this blurring of the meaning of variable is a really nice feature for interactive data analysis, because it allows you to refer to data-vars as is, without any prefix. And this seems to be fairly intuitive, since many newer R users will attempt to write `diamonds[x == 0 | y == 0, ]`. But when you start to program with these tools, you're going to have to grapple with the distinction. And this will be hard because you've never had to think about it before, so it'll take a while for your brain to learn these new concepts and categories. However, once you've teased apart the idea of "variable" in data-variable and env-variable, I think you'll find it fairly straightforward to use.

### The two forms of indirection

The main challenge of data masking arises when you introduce some indirection, i.e. instead of you directly typing the name of a data-variable you want to get it from an env-variable.

There are two main cases:

*   When you have the data-variable in an env-variable that is a functon
    argument[^promise], you need to **embrace** the argument by surrounding 
    it in doubled parentheses, e.g. `filter(df, {{ var }})`.

    ```{r, results = FALSE}
    dist_summary <- function(df, var) {
      df %>%
        summarise(n = n(), min = min({{ var }}), max = max({{ var }}))
    }
    mtcars %>% 
      group_by(cyl) %>% 
      dist_summary(mpg)
    ```

*   When you have an env-variable that contains a character vector, you
    need to index into the `.data` pronoun with `[[`, e.g.  
    `summarise(df, mean = mean(.data[[var]]))`.

    ```{r, results = FALSE}
    for (var in names(mtcars)) {
      mtcars %>% count(.data[[var]]) %>% print()
    }
    ```

    The verbs `across()`, `select()`, `rename()`, and `pull()` use a
    further more restricted form of tidy evaluation called **tidy selection**.
    Rather than data-masking, they provide a specialised domain specific
    language for selecting variables based on their names. Because they don't
    use data-masking they don't provide a `.data` pronoun, so instead you
    need to use the `all_of()` or `any_of()` selectors which take a 
    character vector of variable names:
    
    ```{r}
    for (var in names(mtcars)) {
      mtcars %>% select(all_of(var)) %>% print()
    }
    
    ```

[^promise]: Or technically, a promise, which is what you should search for if you want to learn more. One place to start is <https://adv-r.hadley.nz/functions.html#lazy-evaluation>

### The theory

This document refrains from discussing the underlying theory of tidy evaluation. Thanks to recent improvements in the syntax (particularly the introduction of `{{ }}`), there are very few places that the theory helps you solve day-to-day data science problems. I still believe the theory is beautiful and elegant, but you only need to learn about it if you'll be programming with it extensively. If you'd like to learn more, the best place is the Metaprogramming part of [_Advanced R_](https://adv-r.hadley.nz).

## How tos

The examples here are somewhat inauthentic because we've reduced them down to very simple components to make them easier to understand. They're so simple that you might wonder why we bother writing a function at all. But it's a good idea to learn the ideas on simple examples, so that you're better prepared to apply them to the more complex situations you'll see in your own code.

### How to tell if a function uses tidy evaluation

Tidy evaluation is a property that applies not to an entire function, but to specific arguments of a function. You can tell if an argument uses special evaluation because its documentation will have special a label that looks like `<tidy-eval>`.

### Function with user-supplied data

If you read the documentation for the dplyr verbs, you'll see that they don't use tidy evaluation for the `.data` argument. This makes it simple to reduce duplication when repeated code only varies the data:

```{r, eval = FALSE}
mutate(df1, y = a + x)
mutate(df2, y = a + x)
mutate(df3, y = a + x)
mutate(df4, y = a + x)
```

```{r}
mutate_y <- function(df) {
  mutate(df, y = a + x)
}
```

### Function with a user-supplied expression

What about when a repeated code varies over an argument that uses tidy evaluation?

```{r}
starwars %>%
  group_by(species) %>%
  summarise(mean = mean(mass, na.rm = TRUE))

starwars %>%
  group_by(homeworld) %>%
  summarise(mean = mean(mass, na.rm = TRUE))
```

You'll need to embrace that argument with `{{ }}`

```{r}
my_summarise <- function(df, group_var) {
  df %>%
    group_by({{ group_var }}) %>%
    summarise(mean = mean(mass))
}

my_summarise(starwars, species)
```

This generalises in a straightforward way if you want to use one user supplied expression in multiple places. For example, if you wanted to write a function to reduce the duplication here:

```{r}
df %>% summarise(mean = mean(a), sum = sum(a), n = n())
df %>% summarise(mean = mean(a * b), sum = sum(a * b), n = n())
```

You'd just use:

```{r}
my_summarise2 <- function(df, expr) {
  expr <- enquo(expr)

  df %>% summarise(
    mean = mean({{ expr }}),
    sum = sum({{ expr }}),
    n = n()
  )
}
df %>% my_summarise2(a)
df %>% my_summarise2(a * b)
```

### Function with multiple user-supplied expressions

If you just want to pass expressions along without transforming them, you can use `...`. This is most often useful when you want to give the user full control over a single part of the pipeline, like a `group_by()` or a `mutate()`.

```{r}

my_summarise <- function(df, ...) {
  df %>%
    group_by(...) %>%
    summarise(a = mean(a))
}

my_summarise(starwars, , g2)
```
  
### Function with multiple user-supplied variables

If you want the user to provide a set of variables that are then transformed, use `across()`:

```{r}
my_summarise <- function(df, summary_vars) {
  df %>%
    summarise(across({{ summary_vars }}, mean))
}

my_summarise(df, c(g1, g2))
```

You can use this same idea for multiple sets of input variables:

```{r}
my_summarise <- function(df, group_by, summarise_by) {
  df %>%
    group_by(across({{ group_by }})) %>% 
    summarise(across({{ summarise_by }}, mean))
}
```

### Loop over multiple variables

If you want to loop over variables you need a slightly different approach, because precisely storing expressions in a vector requires greater knowledge of the underlying theory. A simpler approach is to put the variable names in a character vector and use the special `.data` pronoun:

```{r, eval = FALSE}
for (var in names(mtcars)) {
  mtcars %>% count(.data[[var]]) %>% print()
}
```

(Note that `.data` is not a data frame; it's a special construct that allows you to access the current variables either directly, with `.data$x` or indirectly with `.data[[var]]`. Don't expect other functions to work with it.)

### Use a variable from an Shiny input

Many Shiny input controls return character vectors, so you can use the same approach as above: `.data[[input$var]]`.

```{r, eval = FALSE}
library(shiny)
ui <- fluidPage(
  selectInput("var", "Variable", choices = names(diamonds)),
  tableOutput("output")
)
server <- function(input, output, session) {
  data <- reactive(filter(diamonds, .data[[input$var]] > 0))
  output$output <- renderTable(head(data()))
}
```

See <https://mastering-shiny.org/action-tidy.html> for more details and case studies.

### Eliminating the `R CMD check` `NOTE`

```{r}
my_summary_function <- function(data) {
  data %>% 
    filter(x > 0) %>% 
    group_by(grp) %>% 
    summarise(y = mean(y), n = n())
}
```

```
N  checking R code for possible problems
   my_summary_function: no visible binding for global variable ‘x’, ‘grp’, ‘y’
   Undefined global functions or variables:
     x grp y
```

```{r}
#' @importFrom rlang .data
my_summary_function <- function(data) {
  data %>% 
    filter(.data$x > 0) %>% 
    group_by(.data$grp) %>% 
    summarise(y = mean(.data$y), n = n())
}
```
