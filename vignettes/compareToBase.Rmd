---
title: "From base R to dplyr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{From base R to dplyr}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 5)
```

This vignette aims to compare dplyr functions to base R equivalents to facilitate users transitioning from using base R to dplyr. 

# Single-Table Verbs

| base | dplyr    |
|------|------------|
|   `df[order(x), , drop = FALSE]`   | `arrange(df, x)` |
|   `df[!duplicated(x), , drop = FALSE]`, `unique()`   | `distinct(df, x)`  |
|   `df[x & !is.na(x), , drop = FALSE]`, `subset()`   | `filter(df, x)`  |
|   `df$z <- df$x + df$y`, `transform()`   | `mutate(df, z = x + y)`  |
|   `df$x`    | `pull(df, x)` |
|   N/A   | `rename(df, y = x)` |
|   `df[c("x", "y")]`, `subset()`  | `select(df, x, y)` |
|   `df[grepl(names(df), "^x")]` | `select(df, starts_with("x")` |
|   `mean(df$x)` | `summarise(df, mean(x))` |
|   `df[c(1, 2, 5), , drop = FALSE]` | `slice(df, c(1, 2, 5))` |

# Two-Table Verbs

| base | dplyr    |
|------|------------|
|   `merge(df1, df2)`   | `inner_join(df1, df2)` |
|   `merge(df1, df2, all.x = TRUE)`   | `left_join(df1, df2) `  |
|   ` merge(df1, df2, all.y = TRUE)`   | `right_join(df1, df2)`  |
|   `merge(df1, df2, all = TRUE)`   | `full_join(df1, df2)`  |
|   `df1[df1$x %in% df2$x, , drop = FALSE]`    | `semi_join(df1, df2)` |
|   `df1[!df1$x %in% df2$x, , drop = FALSE]` | `anti_join(df1, df2)` |

Overall the main differences between base R and dplyr are:

1. dplyr provides functions to help us manipulate a whole data frame via relevant verbs. This style contrasts base R approaches where we more explicitly manipulate columns within the data frame. 

2. dplyr eliminates the use of `$` to access particular columns of a data frame.

3. Overall, dplyr solutions to data manipulation problems leverage a vocabulary of verbs which do explicit tasks, while base R solutions require using `[` in many different ways depending on the task at hand.

4. Manipulation of grouped data frames is much more streamlined in dplyr thanks to `group_by()`. 

Now we will walk through each of the functions in the above tables, noting the similarities and differences between base R and dplyr.

These dplyr examples come from the [dplyr documentation](https://cran.r-project.org/web/packages/dplyr/dplyr.pdf) and here, they are contrasted with the analogous base R operation(s).

```{r setup}
library(dplyr)
```

# Single-table verbs

For more information about these single-table verbs see `vignette("dplyr")`.

## `arrange()`: Arrange rows by variables

You may want to order a data frame based on the values of one or more columns. In base R you can use the output of `order()` as an index for your data frame. We must remember to use  `drop = F` though to ensure that the result is still a data frame. If our manipulation reduces the data frame to one column and we forget `drop = F`, we will end up with a vector. This can cause problems further into our analysis if we expect a different data type than we actually have. 

By default, both organize in increasing order, but decreasing order is possible. 

```{r}
# base
mtcars[order(mtcars$cyl, mtcars$disp), ,drop = F] %>% head()
mtcars[order(mtcars$cyl, mtcars$disp, decreasing = T), ,drop = F] %>% head() # decreasing
```

In dplyr, we simply choose the verb relevant to our goals: `arrange()`.

```{r}
# dplyr
arrange(mtcars, cyl, disp) %>% head()
arrange(mtcars, desc(cyl), desc(disp)) %>% head() # descending order
```


## `distinct()`: Select distinct/unique rows

We may want to streamline our data frame by only including distinct values of a particular variable. Again, we can't forget `drop = F`. 

```{r}
df <- tibble(
  x = sample(10, 100, rep = TRUE),
  y = sample(10, 100, rep = TRUE)
)

# base
df[!duplicated(df$x), , drop = F] # whole data frame
unique(df$x) # just see the unique values
```

In both base R and dplyr we can either access the entire data frame or just the column of interest. The corresponding dplyr verb is `distinct()`. 

```{r}
# dplyr
distinct(df, x, .keep_all = TRUE) # whole data frame
distinct(df, x) # just see the unique values
```

## `filter()`: Return rows with matching conditions

In base R if we want to narrow our data set based on criteria of interest, `subset()` is used.

```{r}
# base
subset(starwars, species == "Human")
subset(starwars, mass > 1000)
subset(starwars, hair_color == "none" & eye_color == "black")
```

The syntax of dplyr's `filter()` is very similar.

```{r}
# dplyr
filter(starwars, species == "Human")
filter(starwars, mass > 1000)
filter(starwars, hair_color == "none" & eye_color == "black")
```

Both base R and dplyr will drop `NA`s in the process of returning the matching conditions.

## `mutate()`: Create or transform variables

We can create new variables as functions of other ones. In base R we directly create a new variable using `$` and assign it a vector of values. We can also use the function `transform()`.

```{r}
# base
mtcars$cyl2 <- mtcars$cyl * 2
mtcars$cyl4 <- mtcars$cyl2 * 2
head(mtcars)

# or
transform(mtcars, cyl3 = cyl*3) %>% head()
```

In dplyr we `mutate()` the data frame but we do not need to use `$` to refer to new or current variables. Note that we can create a variable using another new variable in the same `mutate()` call. `transform()` does not allow for this. 

```{r}
# dplyr
mtcars %>%
  mutate(
    cyl2 = cyl * 2,
    cyl4 = cyl2 * 2
  ) %>% head()
```

To create a new variable based on a group requires specialized functions in base R. For example, we can take a mean by group using `ave()`.

```{r}
# base
mtcars$avg_mpg_by_cyl <- ave(mtcars$mpg, mtcars$cyl)
```

In dplyr we can use `group_by()` and then define whatever function we want to create a new variable, using `ungroup()` to get back to an ungrouped data frame after our calculation.

```{r}
# dplyr
mtcars = mtcars %>% group_by(cyl) %>% mutate(avg_mpg_by_cyl = mean(mpg)) %>% ungroup()
```

## `pull()`: Pull out a single variable

The dplyr verb `pull()` is equivalent to the base R use of `$`.

```{r}
# base
mtcars[[1]]
mtcars$cyl

# dplyr
mtcars %>% pull(1)
mtcars %>% pull(cyl)
```

## `relocate()`: Change column order

If we want to reorder the column names of a dataframe, we must provide the reordering ourselves in base R. In dplyr we can use `relocate()` which helps us find our new desired locations without knowing the exact number order of the columns.

```{r}
# base
mtcars = mtcars[,c(ncol(mtcars), 1:(ncol(mtcars)-1))] %>% head()

# dplyr
mtcars %>% relocate(avg_mpg_by_cyl) %>% head() # bring last to the front
mtcars %>% relocate(avg_mpg_by_cyl, .before = cyl) %>% head() # alternative approach
```

## `rename()`: Rename variables by name

To rename a variable in base R, we first need to identify which column we want to replace based on `names()`. Then we need to override the name.

```{r}
iris_copy = iris
# base
change_idx <- grep(pattern = "Petal.Length", names(iris))
names(iris)[change_idx] <- "petal_length"
```

In dplyr the `rename()` function takes care of finding the correct column. 

```{r}
# dplyr
rename(iris_copy, petal_length = Petal.Length) %>% head()
```

## `select()`: Select variables by name

To grab (or exclude) certain variables from a data frame in base R, we need to do the work to specify and find the matches.

```{r}
# base
iris[, c("Species", "Petal.Width")] %>% head()
iris[, grepl("^x", names(iris))] %>% head()
iris[, setdiff(names(iris), c("Species", "Petal.Width"))] %>% head()
# all but two particular variables
```


`select()` has some helper functions that can help us obtain (or exclude) multiple columns based on patterns rather than manually specifying them all. Below we show `starts_with()` but addtional ones include `ends.with()`, `contains()`, `matches()`, `num.range()`, `one_of()`, `everything()`, and `group.cols()`.  

```{r}
# dplyr
select(iris, Species, Petal.Width) %>% head()
select(iris, starts_with("Sepal")) %>% head()
select(iris, -c(Species, Petal.Width)) %>% head() # all but two particular variables
```

## `summarise()`: Reduce multiple values down to a single value

We can find summaries of various columns in our data frame using base R functions

```{r}
# base
mean(mtcars$disp)
nrow(mtcars$disp)
```

In dplyr `summarise()` allows us to make these summaries and keep the answers tidier. We also get access to helpers such as `n()` and `n_distinct()` that count entries.


```{r}
# dplyr
mtcars %>%
  summarise(mean = mean(disp), n = n())
```

To get the average of every column in a dataset by a grouping variable, like species, in base R requires a special type of `apply()`. 

```{r}
tapply(iris$Sepal.Width, iris$Species, mean)
```

In dplyr we can use `group_by()` paired with `summarise()` to get the same results. We can also get the mean for every column just as easily.

```{r}
# dplyr
iris %>% group_by(Species) %>% summarise(mean_Sepal_Width = mean(Sepal.Width))
iris %>% group_by(Species) %>% summarise_all(mean) # get means of all columns
```

## `slice()`: Choose rows by position

We've talked a lot about choosing columns of a data frame, but we can also choose rows of our data frame. In base R we manually subset the data frame using specified indices. 

```{r}
# base
mtcars[25:nrow(mtcars), ]
```

In dplyr `slice()` helps us access particular rows.

```{r}
# dplyr
slice(mtcars, 25:n())
```

# Two-table verbs

When we want to merge two data frames (refered to as `x` and `y` in base R's `merge() ` arguments), we have a variety of different ways to bring them together. Various base R `merge()` calls are replaced by a variety of dplyr `join()` functions.

For more information about two-table verbs, see `vignette("two-table")`.

## Mutating joins: Join two tables together

If we want only rows that match in both data sets, we use dplyr's `inner_join()`. This drops the rows from the first data frame that do not occur in the second data frame (denoted by base R as `all.x = F`) and the rows from the second data frame that do not occur in the first data frame (denoted by base R as `all.y = F`).

In base R the resulting merged data frame has rows that are sorted in alphabetical order of the common solumns while in dplyr, the order of the first data frame's rows is preserved.

Left, right, and full joins drop rows without matches from the second data frame, first data frame, and neither data frame respectively. 

```{r}
## Which band members also play instruments and what instruments do they play?

# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = F, all.y = F)

# dplyr
band_members %>% inner_join(band_instruments)

## What instrument does every band member play?

# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = T, all.y = F)

# dplyr
band_members %>% left_join(band_instruments)

## Which instruments are played and who are they played by?

# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = F, all.y = T)

# dplyr
band_members %>% right_join(band_instruments)

## What band members and band instruments exist?

# base
merge(band_members, band_instruments, by.x = "name", by.y = "name", all.x = T, all.y = T)
merge(band_members, band_instruments, by.x = "name", by.y = "name", all = T) # shortcut

# dplyr
band_members %>% full_join(band_instruments)
```

## `semi_join()`: Join two tables together

If we do not want to add information from another data frame but we care about the rows in one data frame narrowed to those that have a match in another data frame we can use dplyr's `semi_join()`. In base R we have to use `%in%` to help us find the correct rows to access. The `drop = F` option is again needed to ensure we end up with a data frame.


```{r}
## Which band members play instruments?

# base
band_members[band_members$name %in% band_instruments$name, , drop = F]

# dplyr
band_members %>% semi_join(band_instruments)
```

Note that if we want to perform a semi-join based on more than one match criteria in base R, it is non-trivial. We cannot just do two `%in%` statements connected with a logical expression because we need joint matches. However, in dplyr multiple match criteria are easily handled. 

## `anti_join()`: Join two tables together

If we do not want to add information from another data frame but we care about the rows in one data frame that do not match another data frame we can use dplyr's `anti_join()`. We can use the negation of `%in%` in base R to help us find the correct rows to access, and we need to remember the `drop = F` option.

```{r}
## Which band members do not play instruments?

# base
band_members[!band_members$name %in% band_instruments$name, , drop = FALSE]

# dplyr
band_members %>% anti_join(band_instruments)
```

