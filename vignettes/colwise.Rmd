---
title: "colwise operations"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{colwise}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
```

It's often useful to perform the same operation on multiple columns but copying and pasting is both tedious and error prone:

```{r, eval = FALSE}
df %>% 
  group_by(g1, g2) %>% 
  summarise(a = mean(a), b = mean(b), c = mean(c), d = mean(c))
```

This vignette will introduce you to the `across()` function, which allows you to replace the above code with:

```{r, eval = FALSE}
df %>% 
  group_by(g1, g2) %>% 
  summarise(across(a:d, mean))
```

We'll start by discussing the basic usage of `across()`, particularly as it applies to `summarise()`, and show how to use it with multiple functions. We'll then show a few uses with other verbs. We'll finish off with a bit of history, showing why `across()` is better than our last approach (the `_if()`, `_at()` and `_all()` functions) and how you can translate your old code to the new syntax.

```{r setup}
library(dplyr, warn.conflicts = FALSE)
```
 
## Basic usage

`across()` has two primary arguments:

* The first argument, `cols`, selects the variables you want to operate on.
  It uses tidy selection, so that you pick variables using the same syntax
  as `select()`, either by position, name, type, or any combination thereof.
  `across()` always leaves grouping variables alone.

* The second argument, `fns`, is a function or list of functions to apply to
  each column. This can also be a purrr style formula (or list of formulas)
  like `~ .x / 2`. (This argument is optional, and you can omit it if you want
  just get the underlying data frame; you'll see that technique used in
  `vignette("rowwise")`.)

`across()` is most commonly used with `summarise()`:

```{r}
starwars %>% summarise(across(is.character, ~ length(unique(.x))))

starwars %>% 
  group_by(homeworld) %>% 
  summarise(n = n(), across(is.numeric, ~ mean(.x, na.rm = TRUE))) %>% 
  filter(n > 1)
```
If you need to, you can access the value of the "current" column inside by calling `cur_column()`.

### Multiple functions

```{r}
starwars %>% summarise(
  across(is.numeric, list(min = ~min(.x, na.rm = TRUE), max = ~max(.x, na.rm = TRUE)))
)
```

You can control how the names are created with the `name` argument which takes a [glue](http://glue.tidyverse.org/) spec:

```{r}
starwars %>% summarise(
  across(is.numeric, list(min = ~min(.x, na.rm = TRUE), max = ~max(.x, na.rm = TRUE)), names = "{fn}.{col}")
)
```
If you'd prefer all summaries with the same function to be grouped together, you can expand the calls yourself:

```{r}
starwars %>% summarise(
  across(is.numeric, ~min(.x, na.rm = TRUE), names = "min_{col}"),
  across(is.numeric, ~max(.x, na.rm = TRUE), names = "max_{col}")
)
```
(This may one day become an argument to `across()` but we're not yet sure how it should work.)

### Other verbs

*   Rescale all numeric variables to range 0-1:

    ```{r}
    rescale01 <- function(x) {
      rng <- range(x, na.rm = TRUE)
      (x - rng[1]) / (rng[2] - rng[1])
    }
    df <- tibble(x = 1:5, y = rnorm(5))
    df %>% mutate(across(is.numeric, rescale01))
    ```

*   Find all rows where no variable has missing values:

    ```{r}
    starwars %>% filter(across(everything(), ~ !is.na(.x)))
    ```

For some verbs, like `group_by()`, `count()` and `distinct()`, you can omit the summary functions:

*   Find all distinct 

    ```{r}
    starwars %>% distinct(across(contains("color")))
    ```

*   Count all combinations of variables with a given pattern:

    ```{r}
    starwars %>% count(across(contains("color")), sort = TRUE)
    ```

  

## `_if`, `_at`, `_all`

Prior versions of dplyr solved this problem in a different way: with a family of suffixes. These functions solved a pressing need and are used by many people, but are now superseded. That means that they'll stay around, but won't receive any new features and only critical bug fixes. Why did decide to move away from these functions in favour of `across()`?

1.  `across()` makes it possible to express useful summaries that were 
    previously impossible:

    ```{r, eval = FALSE}
    df %>%
      group_by(g1, g2) %>% 
      summarise(
        n = n(), 
        across(is.numeric, mean), 
        across(is.factor, nlevels)
      )
    ```

1.  `across()` reduces the number of functions that dplyr needs to provide. 
    This makes dplyr easier to use (because there are fewer functions to 
    remember) and also makes it easier to implement new verbs (since you only 
    need to implement one function, not four).

1.  `across()` unifies `_if` and `_at` semantics so that you can select by 
    position, name, and type, and create compound selections that were 
    previously impossible. For example, you can now select on all numeric 
    columns whose name begins with "x": `across(is.numeric & starts_with("x"))`.

1.  `across()` doesn't need to use `vars()`. The `_at()` functions are the only
    place in dplyr where you have to manually quote variable names using 
    `vars()`, which makes them a little weird and hence harder to remember.

It's disappointing that we didn't discover `across()` earlier, and instead worked through several false starts (first not realising that it was a common problem, then with `_each()` and then with `_if()`/`_at()`/`_all()`). But there were three crucial pieces that we only worked out recently:

* You can have a column of a data frame that is itself a data frame 
  (this is something provided by base R, but it's not very well documented, and
  it took a while to see that it was really useful not just a theoretical
  curiosity.)

* We can use data frames to allow summary functions to return multiple columns.

* We can use of absence of an outer name as a convention that you want to
  unpack a data frame column into individual columns.

### Translation pattern

Fortunately, it's generally straightforward to translate your existing code to use `across()`:

*   Strip the `_if()`, `_at()` and `_all()` suffix off the function.

*   Call `across()`. The first argument will be:

    1. For `_if()`, the old second argument.
    1. For `_at()`, the old second argument, with the call to `vars()` removed.
    1. For `_all()`, `everything()`.

    The subsequent arguments can be copied as is.

```{r, eval = FALSE}
df %>% mutate_if(is.numeric, mean, na.rm = TRUE)
# ->
df %>% mutate(across(is.numeric, mean, na.rm = TRUE))

df %>% mutate_at(vars(c(x, starts_with("y"))), mean)
# ->
df %>% mutate(across(c(x, starts_with("y")), mean, na.rm = TRUE))

df %>% mutate_all(mean)
# ->
df %>% mutate(across(everything(), mean))
```

There are a few exceptions to this rule:

*   `rename_*()` and `select_*()` follow a different pattern. They already
    have select semantics, so are generally used in a different way that doesn't
    have a direct equivalent with `across()`. Still not sure what the replacement
    is: see <https://github.com/tidyverse/dplyr/issues/4771> for details.

*   `filter()` previously supplied the `all_vars()` and `any_vars()` helpers.
    `across()` is equivalent to `all_vars()`. There's no direct replacement
    for `any_vars()` but you can make a helper yourself:
  
    ```{r}
    df <- tibble(x = c("a", "b"), y = c(1, 1), z = c(-1, 1))
    
    # Find all rows where EVERY numeric variable is greater than zero
    df %>% filter(across(is.numeric, ~ .x > 0))
    
    # Find all rows where ANY numeric variable is greater than zero
    rowAny <- function(x) rowSums(x) > 0
    df %>% filter(rowAny(across(is.numeric, ~ .x > 0)))
    ```
    
*   NB: when used in a `mutate()`, all transformation performed by an `across()` 
    are applied at once. This is different to the behaviour of `mutate_if()`,
    `mutate_at()`, and `mutate_all()` which apply the transformations one at 
    a time. We expect that you'll generally find the new behaviour more useful:

    ```{r}
    df <- tibble(x = 2, y = 4, z = 8)
    df %>% mutate_all(~ .x / y)
    
    df %>% mutate(across(everything(), ~ .x / y))
    ```
